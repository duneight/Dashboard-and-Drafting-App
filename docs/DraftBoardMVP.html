<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fantasy Keepers Table — 2025 (Upgraded)</title>
  <!-- Using Tailwind CDN for development - replace with local build for production -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            'fantasy-dark': '#0f172a',
            'fantasy-card': '#111827',
            'fantasy-muted': '#9ca3af',
            'fantasy-line': '#374151'
          },
          animation: {
            'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
            'bounce-subtle': 'bounce 2s infinite'
          }
        }
      }
    }
  </script>

  <script>
    // --- DRAFT STATE MANAGEMENT ---
    let draftHistory = [];
    let historyIndex = -1;
    let currentPick = 1;
    let draftStats = {
      totalPicks: 0,
      picksByPosition: { F: 0, D: 0, G: 0 },
      picksByTeam: {},
      draftProgress: 0
    };

    const playerRankings = [
      {rank: 1, name: "Connor McDavid", team: "EDM", pos: "C", avg: 1.6},
      {rank: 2, name: "Nathan MacKinnon", team: "COL", pos: "C", avg: 1.8},
      {rank: 3, name: "Nikita Kucherov", team: "TB", pos: "RW", avg: 3.0},
      {rank: 4, name: "Leon Draisaitl", team: "EDM", pos: "C,LW", avg: 3.6},
      {rank: 5, name: "David Pastrnak", team: "BOS", pos: "RW", avg: 5.4},
      {rank: 6, name: "Cale Makar", team: "COL", pos: "D", avg: 6.8},
      {rank: 7, name: "Kirill Kaprizov", team: "MIN", pos: "LW", avg: 7.4},
      {rank: 8, name: "Auston Matthews", team: "TOR", pos: "C", avg: 8.0},
      {rank: 9, name: "Connor Hellebuyck", team: "WPG", pos: "G", avg: 8.2},
      {rank: 10, name: "Mikko Rantanen", team: "DAL", pos: "LW,RW", avg: 10.6},
      {rank: 11, name: "Brady Tkachuk", team: "OTT", pos: "C,LW", avg: 11.6},
      {rank: 12, name: "Kyle Connor", team: "WPG", pos: "LW", avg: 13.4},
      {rank: 13, name: "William Nylander", team: "TOR", pos: "C,RW", avg: 14.0},
      {rank: 14, name: "Jack Eichel", team: "VGK", pos: "C", avg: 15.4},
      {rank: 15, name: "Artemi Panarin", team: "NYR", pos: "LW", avg: 15.6},
      {rank: 16, name: "Jack Hughes", team: "NJ", pos: "C,LW", avg: 16.6},
      {rank: 17, name: "Quinn Hughes", team: "VAN", pos: "D", avg: 17.6},
      {rank: 18, name: "Mitch Marner", team: "VGK", pos: "RW", avg: 18.6},
      {rank: 19, name: "Andrei Vasilevskiy", team: "TB", pos: "G", avg: 18.6},
      {rank: 20, name: "Brayden Point", team: "TB", pos: "C", avg: 21.6},
      {rank: 21, name: "Tage Thompson", team: "BUF", pos: "C,RW", avg: 22.6},
      {rank: 22, name: "Evan Bouchard", team: "EDM", pos: "D", avg: 23.8},
      {rank: 23, name: "Sam Reinhart", team: "FLA", pos: "C,RW", avg: 25.8},
      {rank: 24, name: "Jason Robertson", team: "DAL", pos: "LW,RW", avg: 25.8},
      {rank: 25, name: "Zach Werenski", team: "CBJ", pos: "D", avg: 27.8},
      {rank: 26, name: "Jake Guentzel", team: "TB", pos: "LW", avg: 28.2},
      {rank: 27, name: "Sidney Crosby", team: "PIT", pos: "C", avg: 28.4},
      {rank: 28, name: "Filip Forsberg", team: "NSH", pos: "LW", avg: 29.2},
      {rank: 29, name: "Jake Oettinger", team: "DAL", pos: "G", avg: 30.0},
      {rank: 30, name: "Clayton Keller", team: "UTA", pos: "LW,RW", avg: 30.2},
      {rank: 31, name: "Martin Necas", team: "COL", pos: "RW", avg: 31.4},
      {rank: 32, name: "Jesper Bratt", team: "NJ", pos: "LW,RW", avg: 34.6},
      {rank: 33, name: "Matt Boldy", team: "MIN", pos: "LW,RW", avg: 34.8},
      {rank: 34, name: "Igor Shesterkin", team: "NYR", pos: "G", avg: 35.2},
      {rank: 35, name: "Tim Stützle", team: "OTT", pos: "C,LW", avg: 35.2},
      {rank: 36, name: "Rasmus Dahlin", team: "BUF", pos: "D", avg: 36.0},
      {rank: 37, name: "Sergei Bobrovsky", team: "FLA", pos: "G", avg: 37.4},
      {rank: 38, name: "Brandon Hagel", team: "TB", pos: "LW,RW", avg: 37.6},
      {rank: 39, name: "Sebastian Aho", team: "CAR", pos: "C", avg: 39.0},
      {rank: 40, name: "J.T. Miller", team: "NYR", pos: "C,RW", avg: 39.0},
      {rank: 41, name: "Mark Scheifele", team: "WPG", pos: "C", avg: 41.8},
      {rank: 42, name: "Adrian Kempe", team: "LA", pos: "RW", avg: 42.0},
      {rank: 43, name: "Mackenzie Blackwood", team: "COL", pos: "G", avg: 44.8},
      {rank: 44, name: "Cole Caufield", team: "MTL", pos: "LW,RW", avg: 45.8},
      {rank: 45, name: "Nick Suzuki", team: "MTL", pos: "C", avg: 46.0},
      {rank: 46, name: "Wyatt Johnston", team: "DAL", pos: "C,RW", avg: 48.8},
      {rank: 47, name: "Matvei Michkov", team: "PHI", pos: "RW", avg: 50.6},
      {rank: 48, name: "Adam Fox", team: "NYR", pos: "D", avg: 50.6},
      {rank: 49, name: "Macklin Celebrini", team: "SJ", pos: "C", avg: 51.0},
      {rank: 50, name: "Alex Ovechkin", team: "WSH", pos: "LW,RW", avg: 51.6},
      {rank: 51, name: "Lucas Raymond", team: "DET", pos: "RW", avg: 53.2},
      {rank: 52, name: "Victor Hedman", team: "TB", pos: "D", avg: 54.4},
      {rank: 53, name: "Roman Josi", team: "NSH", pos: "D", avg: 55.8},
      {rank: 54, name: "Josh Morrissey", team: "WPG", pos: "D", avg: 58.6},
      {rank: 55, name: "Darcy Kuemper", team: "LA", pos: "G", avg: 59.0},
      {rank: 56, name: "Seth Jarvis", team: "CAR", pos: "C,LW,RW", avg: 59.0},
      {rank: 57, name: "Dylan Larkin", team: "DET", pos: "C", avg: 60.6},
      {rank: 58, name: "Travis Konecny", team: "PHI", pos: "LW,RW", avg: 60.8},
      {rank: 59, name: "Dylan Guenther", team: "UTA", pos: "RW", avg: 61.0},
      {rank: 60, name: "John Tavares", team: "TOR", pos: "C", avg: 62.8},
      {rank: 61, name: "Alex DeBrincat", team: "DET", pos: "LW,RW", avg: 63.6},
      {rank: 62, name: "Lane Hutson", team: "MTL", pos: "D", avg: 63.8},
      {rank: 63, name: "Connor Bedard", team: "CHI", pos: "C,RW", avg: 64.4},
      {rank: 64, name: "Kevin Fiala", team: "LA", pos: "LW", avg: 66.4},
      {rank: 65, name: "Nico Hischier", team: "NJ", pos: "C", avg: 68.8},
      {rank: 66, name: "Jordan Kyrou", team: "STL", pos: "RW", avg: 69.6},
      {rank: 67, name: "Adin Hill", team: "VGK", pos: "G", avg: 69.8},
      {rank: 68, name: "Robert Thomas", team: "STL", pos: "C", avg: 70.2},
      {rank: 69, name: "Filip Gustavsson", team: "MIN", pos: "G", avg: 72.2},
      {rank: 70, name: "Mika Zibanejad", team: "NYR", pos: "C,RW", avg: 72.4},
      {rank: 71, name: "Elias Pettersson", team: "VAN", pos: "C,LW", avg: 74.4},
      {rank: 72, name: "Matthew Knies", team: "TOR", pos: "LW", avg: 74.6},
      {rank: 73, name: "Roope Hintz", team: "DAL", pos: "C", avg: 74.8},
      {rank: 74, name: "Kirill Marchenko", team: "CBJ", pos: "RW", avg: 75.8},
      {rank: 75, name: "Nazem Kadri", team: "CGY", pos: "C", avg: 78.2},
      {rank: 76, name: "Carter Verhaeghe", team: "FLA", pos: "LW", avg: 79.2},
      {rank: 77, name: "Shea Theodore", team: "VGK", pos: "D", avg: 79.6},
      {rank: 78, name: "Dustin Wolf", team: "CGY", pos: "G", avg: 81.0},
      {rank: 79, name: "Andrei Svechnikov", team: "CAR", pos: "LW,RW", avg: 84.4},
      {rank: 80, name: "JJ Peterka", team: "UTA", pos: "LW,RW", avg: 85.6},
      {rank: 81, name: "Nikolaj Ehlers", team: "CAR", pos: "LW,RW", avg: 85.6},
      {rank: 82, name: "Jake Sanderson", team: "OTT", pos: "D", avg: 87.0},
      {rank: 83, name: "Mackenzie Weegar", team: "CGY", pos: "D", avg: 87.4},
      {rank: 84, name: "Anthony Stolarz", team: "TOR", pos: "G", avg: 91.0},
      {rank: 85, name: "Alex Tuch", team: "BUF", pos: "RW", avg: 91.8},
      {rank: 86, name: "Logan Thompson", team: "WSH", pos: "G", avg: 92.8},
      {rank: 87, name: "Jacob Markstrom", team: "NJ", pos: "G", avg: 93.2},
      {rank: 88, name: "Ilya Sorokin", team: "NYI", pos: "G", avg: 93.4},
      {rank: 89, name: "Linus Ullmark", team: "OTT", pos: "G", avg: 94.0},
      {rank: 90, name: "Valeri Nichushkin", team: "COL", pos: "LW,RW", avg: 96.0},
      {rank: 91, name: "Adam Fantilli", team: "CBJ", pos: "C", avg: 96.2},
      {rank: 92, name: "Dougie Hamilton", team: "NJ", pos: "D", avg: 96.6},
      {rank: 93, name: "Pavel Dorofeyev", team: "VGK", pos: "LW,RW", avg: 97.4},
      {rank: 94, name: "Vincent Trocheck", team: "NYR", pos: "C", avg: 99.2},
      {rank: 95, name: "Stuart Skinner", team: "EDM", pos: "G", avg: 100.2},
      {rank: 96, name: "Drake Batherson", team: "OTT", pos: "LW,RW", avg: 100.6},
      {rank: 97, name: "Tom Wilson", team: "WSH", pos: "RW", avg: 101.2},
      {rank: 98, name: "Dylan Holloway", team: "STL", pos: "C,LW", avg: 102.8},
      {rank: 99, name: "Logan Cooley", team: "UTA", pos: "C", avg: 103.6},
      {rank: 100, name: "Juuse Saros", team: "NSH", pos: "G", avg: 103.6},
      {rank: 101, name: "Quinton Byfield", team: "LA", pos: "C,LW", avg: 105.0},
      {rank: 102, name: "Timo Meier", team: "NJ", pos: "LW,RW", avg: 106.0},
      {rank: 103, name: "Cutter Gauthier", team: "ANA", pos: "C,LW", avg: 107.0},
      {rank: 104, name: "Bo Horvat", team: "NYI", pos: "C", avg: 108.0},
      {rank: 105, name: "Moritz Seider", team: "DET", pos: "D", avg: 109.0},
      {rank: 106, name: "Leo Carlsson", team: "ANA", pos: "C", avg: 110.0},
      {rank: 107, name: "Miro Heiskanen", team: "DAL", pos: "D", avg: 111.0},
      {rank: 108, name: "Matthew Tkachuk", team: "FLA", pos: "LW,RW", avg: 112.0},
      {rank: 109, name: "Aliaksei Protas", team: "WSH", pos: "C,LW,RW", avg: 113.0},
      {rank: 110, name: "Juraj Slafkovsky", team: "MTL", pos: "LW", avg: 114.0},
      {rank: 111, name: "Dylan Strome", team: "WSH", pos: "C,LW", avg: 115.0},
      {rank: 112, name: "Thomas Harley", team: "DAL", pos: "D", avg: 116.0},
      {rank: 113, name: "Juraj Slafkovsky", team: "MTL", pos: "LW,RW", avg: 104.8},
      {rank: 114, name: "Zach Hyman", team: "EDM", pos: "LW,RW", avg: 104.8},
      {rank: 115, name: "Joel Eriksson Ek", team: "MIN", pos: "C", avg: 105.8},
      {rank: 116, name: "Dylan Strome", team: "WSH", pos: "C", avg: 106.0},
      {rank: 117, name: "Timo Meier", team: "NJ", pos: "LW,RW", avg: 106.4},
      {rank: 118, name: "Quinton Byfield", team: "LA", pos: "C,LW", avg: 106.6},
      {rank: 119, name: "Sam Montembeault", team: "MTL", pos: "G", avg: 107.0},
      {rank: 120, name: "Bo Horvat", team: "NYI", pos: "C", avg: 109.0},
      {rank: 121, name: "Jordan Binnington", team: "STL", pos: "G", avg: 110.4},
      {rank: 122, name: "Matthew Tkachuk", team: "FLA", pos: "LW,RW", avg: 111.2},
      {rank: 123, name: "Thomas Harley", team: "DAL", pos: "D", avg: 111.6},
      {rank: 124, name: "Moritz Seider", team: "DET", pos: "D", avg: 111.8},
      {rank: 125, name: "Mathew Barzal", team: "NYI", pos: "C,RW", avg: 112.8},
      {rank: 126, name: "Mikhail Sergachev", team: "UTA", pos: "D", avg: 119.0},
      {rank: 127, name: "Jared McCann", team: "SEA", pos: "C,LW", avg: 122.8},
      {rank: 128, name: "Sam Bennett", team: "FLA", pos: "C", avg: 123.2},
      {rank: 129, name: "Rickard Rakell", team: "PIT", pos: "C,LW,RW", avg: 124.6},
      {rank: 130, name: "Matt Duchene", team: "DAL", pos: "C,RW", avg: 125.0},
      {rank: 131, name: "Miro Heiskanen", team: "DAL", pos: "D", avg: 125.8},
      {rank: 132, name: "Mark Stone", team: "VGK", pos: "RW", avg: 127.0},
      {rank: 133, name: "Gabriel Vilardi", team: "WPG", pos: "C,RW", avg: 128.8},
      {rank: 134, name: "Karel Vejmelka", team: "UTA", pos: "G", avg: 129.2},
      {rank: 135, name: "Bryan Rust", team: "PIT", pos: "RW", avg: 129.6},
      {rank: 136, name: "Ivan Demidov", team: "MTL", pos: "RW", avg: 129.8},
      {rank: 137, name: "Frederik Andersen", team: "CAR", pos: "G", avg: 130.4},
      {rank: 138, name: "Pyotr Kochetkov", team: "CAR", pos: "G", avg: 130.8},
      {rank: 139, name: "Steven Stamkos", team: "NSH", pos: "C,LW,RW", avg: 133.2},
      {rank: 140, name: "Owen Tippett", team: "PHI", pos: "LW,RW", avg: 133.8},
      {rank: 141, name: "Tomas Hertl", team: "VGK", pos: "C,LW", avg: 134.8},
      {rank: 142, name: "Will Smith", team: "SJ", pos: "C,RW", avg: 136.8},
      {rank: 143, name: "Thatcher Demko", team: "VAN", pos: "G", avg: 138.2},
      {rank: 144, name: "Ryan Nugent-Hopkins", team: "EDM", pos: "C,LW", avg: 139.0},
      {rank: 145, name: "Jeremy Swayman", team: "BOS", pos: "G", avg: 139.2},
      {rank: 146, name: "Jakob Chychrun", team: "WSH", pos: "D", avg: 141.8},
      {rank: 147, name: "Tyler Toffoli", team: "SJ", pos: "LW,RW", avg: 142.6},
      {rank: 148, name: "Jonathan Marchessault", team: "NSH", pos: "RW", avg: 142.8},
      {rank: 149, name: "Noah Dobson", team: "MTL", pos: "D", avg: 143.0},
      {rank: 150, name: "Joey Daccord", team: "SEA", pos: "G", avg: 143.6},
      {rank: 151, name: "John Carlson", team: "WSH", pos: "D", avg: 144.0},
      {rank: 152, name: "Jackson Lacombe", team: "ANA", pos: "D", avg: 144.2},
      {rank: 153, name: "Brock Boeser", team: "VAN", pos: "RW", avg: 145.2},
      {rank: 154, name: "Charlie McAvoy", team: "BOS", pos: "D", avg: 145.6},
      {rank: 155, name: "Pavel Buchnevich", team: "STL", pos: "C,LW,RW", avg: 147.0},
      {rank: 156, name: "Patrick Kane", team: "DET", pos: "RW", avg: 147.0},
      {rank: 157, name: "Brock Nelson", team: "COL", pos: "C", avg: 147.4},
      {rank: 158, name: "Marco Kasper", team: "DET", pos: "C,LW", avg: 149.8},
      {rank: 159, name: "Leo Carlsson", team: "ANA", pos: "C", avg: 150.0},
      {rank: 160, name: "Will Cuylle", team: "NYR", pos: "LW,RW", avg: 150.0},
      {rank: 161, name: "Brad Marchand", team: "FLA", pos: "LW", avg: 150.2},
      {rank: 162, name: "Lukas Dostal", team: "ANA", pos: "G", avg: 151.4},
      {rank: 163, name: "Alexis Lafrenière", team: "NYR", pos: "LW,RW", avg: 151.6},
      {rank: 164, name: "Jonathan Huberdeau", team: "CGY", pos: "C,LW", avg: 152.6},
      {rank: 165, name: "Cutter Gauthier", team: "ANA", pos: "LW", avg: 152.8},
      {rank: 166, name: "Mason McTavish", team: "ANA", pos: "C", avg: 154.6},
      {rank: 167, name: "John Gibson", team: "DET", pos: "G", avg: 155.2},
      {rank: 168, name: "Dylan Cozens", team: "OTT", pos: "C", avg: 156.0},
      {rank: 169, name: "Shayne Gostisbehere", team: "CAR", pos: "D", avg: 156.6},
      {rank: 170, name: "Chris Kreider", team: "ANA", pos: "LW", avg: 157.4},
      {rank: 171, name: "Luke Hughes", team: "NJ", pos: "D", avg: 157.4},
      {rank: 172, name: "Joseph Woll", team: "TOR", pos: "G", avg: 158.4},
      {rank: 173, name: "Sean Monahan", team: "CBJ", pos: "C", avg: 159.0},
      {rank: 174, name: "Vince Dunn", team: "SEA", pos: "D", avg: 160.4},
      {rank: 175, name: "Matt Coronato", team: "CGY", pos: "RW", avg: 161.2},
      {rank: 176, name: "Evgeni Malkin", team: "PIT", pos: "C,LW", avg: 163.2},
      {rank: 177, name: "Kent Johnson", team: "CBJ", pos: "C,LW,RW", avg: 163.8},
      {rank: 178, name: "Erik Karlsson", team: "PIT", pos: "D", avg: 164.0},
      {rank: 179, name: "Artturi Lehkonen", team: "COL", pos: "LW,RW", avg: 165.2},
      {rank: 180, name: "Gabriel Landeskog", team: "COL", pos: "LW", avg: 165.6},
      {rank: 181, name: "Pierre-Luc Dubois", team: "WSH", pos: "C,LW", avg: 165.6},
      {rank: 182, name: "Seth Jones", team: "FLA", pos: "D", avg: 165.6},
      {rank: 183, name: "Marco Rossi", team: "MIN", pos: "C", avg: 170.0},
      {rank: 184, name: "Brandon Montour", team: "SEA", pos: "D", avg: 170.6},
      {rank: 185, name: "Anze Kopitar", team: "LA", pos: "C", avg: 170.8},
      {rank: 186, name: "Morgan Geekie", team: "BOS", pos: "C,LW,RW", avg: 171.6},
      {rank: 187, name: "Ryan Donato", team: "CHI", pos: "C,LW,RW", avg: 172.2},
      {rank: 188, name: "Morgan Rielly", team: "TOR", pos: "D", avg: 175.8},
      {rank: 189, name: "William Eklund", team: "SJ", pos: "LW", avg: 176.0},
      {rank: 190, name: "Nick Schmaltz", team: "UTA", pos: "C,RW", avg: 176.8},
      {rank: 191, name: "Devon Toews", team: "COL", pos: "D", avg: 178.2},
      {rank: 192, name: "Troy Terry", team: "ANA", pos: "RW", avg: 184.4},
      {rank: 193, name: "Aliaksei Protas", team: "WSH", pos: "LW,RW", avg: 185.2},
      {rank: 194, name: "Claude Giroux", team: "OTT", pos: "LW,RW", avg: 185.2},
      {rank: 195, name: "Logan Stankoven", team: "CAR", pos: "C,RW", avg: 185.4},
      {rank: 196, name: "Josh Norris", team: "BUF", pos: "C", avg: 187.0},
      {rank: 197, name: "Drew Doughty", team: "LA", pos: "D", avg: 188.0},
      {rank: 198, name: "Tyler Seguin", team: "DAL", pos: "C,RW", avg: 189.2},
      {rank: 199, name: "Cole Perfetti", team: "WPG", pos: "C,LW,RW", avg: 189.6},
      {rank: 200, name: "Dmitri Voronkov", team: "CBJ", pos: "LW", avg: 190.2},
      {rank: 201, name: "Connor McMichael", team: "WSH", pos: "LW", avg: 190.6},
      {rank: 202, name: "Jimmy Snuggerud", team: "STL", pos: "RW", avg: 180.3},
      {rank: 203, name: "Ivan Barbashev", team: "VGK", pos: "LW", avg: 195.2},
      {rank: 204, name: "Anton Lundell", team: "FLA", pos: "C", avg: 181.3},
      {rank: 205, name: "Jake DeBrusk", team: "VAN", pos: "LW,RW", avg: 196.4},
      {rank: 206, name: "Kiefer Sherwood", team: "VAN", pos: "RW", avg: 196.8},
      {rank: 207, name: "Jackson Blake", team: "CAR", pos: "RW", avg: 198.2},
      {rank: 208, name: "Zeev Buium", team: "MIN", pos: "D", avg: 185.8},
      {rank: 209, name: "Tony DeAngelo", team: "NYI", pos: "D", avg: 200.0},
      {rank: 210, name: "Sam Rinzel", team: "CHI", pos: "D", avg: 200.8},
      {rank: 211, name: "Conor Garland", team: "VAN", pos: "RW", avg: 201.0},
      {rank: 212, name: "Aaron Ekblad", team: "FLA", pos: "D", avg: 201.8},
      {rank: 213, name: "Brayden Schenn", team: "STL", pos: "C", avg: 202.6},
      {rank: 214, name: "Ukko-Pekka Luukkonen", team: "BUF", pos: "G", avg: 204.2},
      {rank: 215, name: "Andrei Kuzmenko", team: "LA", pos: "LW,RW", avg: 205.4},
      {rank: 216, name: "Jeff Skinner", team: "SJ", pos: "LW", avg: 194.3},
      {rank: 217, name: "Elias Lindholm", team: "BOS", pos: "C", avg: 206.2},
      {rank: 218, name: "Brock Faber", team: "MIN", pos: "D", avg: 196.8},
      {rank: 219, name: "Anthony Cirelli", team: "TB", pos: "C", avg: 208.2},
      {rank: 220, name: "Thomas Chabot", team: "OTT", pos: "D", avg: 198.5},
      {rank: 221, name: "Frank Vatrano", team: "ANA", pos: "C,LW", avg: 198.5},
      {rank: 222, name: "Trevor Zegras", team: "PHI", pos: "C", avg: 199.8},
      {rank: 223, name: "Gustav Forsling", team: "FLA", pos: "D", avg: 200.8},
      {rank: 224, name: "Noah Hanifin", team: "VGK", pos: "D", avg: 212.0},
      {rank: 225, name: "Frank Nazar", team: "CHI", pos: "C", avg: 202.3},
      {rank: 226, name: "Zayne Parekh", team: "CGY", pos: "D", avg: 190.7},
      {rank: 227, name: "Mason Marchment", team: "SEA", pos: "LW", avg: 206.5},
      {rank: 228, name: "Evander Kane", team: "VAN", pos: "LW", avg: 207.5},
      {rank: 229, name: "Matty Beniers", team: "SEA", pos: "C", avg: 218.4},
      {rank: 230, name: "Anders Lee", team: "NYI", pos: "LW", avg: 219.0},
      {rank: 231, name: "Jet Greaves", team: "CBJ", pos: "G", avg: 212.3},
      {rank: 232, name: "Spencer Knight", team: "CHI", pos: "G", avg: 214.0},
      {rank: 233, name: "Pavel Zacha", team: "BOS", pos: "C,LW", avg: 214.5},
      {rank: 234, name: "Cam Fowler", team: "STL", pos: "D", avg: 202.3},
      {rank: 235, name: "Rasmus Andersson", team: "CGY", pos: "D", avg: 206.3},
      {rank: 236, name: "Mackie Samoskevich", team: "FLA", pos: "RW", avg: 218.0},
      {rank: 237, name: "Shane Wright", team: "SEA", pos: "C", avg: 224.8},
      {rank: 238, name: "Ryan Leonard", team: "WSH", pos: "RW", avg: 218.3},
      {rank: 239, name: "Darnell Nurse", team: "EDM", pos: "D", avg: 210.7},
      {rank: 240, name: "Boone Jenner", team: "CBJ", pos: "C,LW", avg: 213.7},
      {rank: 241, name: "Patrik Laine", team: "MTL", pos: "LW,RW", avg: 228.8},
      {rank: 242, name: "Jiri Kulich", team: "BUF", pos: "C", avg: 223.5},
      {rank: 243, name: "Jamie Benn", team: "DAL", pos: "C,LW", avg: 225.5},
      {rank: 244, name: "Ryan O'Reilly", team: "NSH", pos: "C", avg: 225.5},
      {rank: 245, name: "Alexander Nikishin", team: "CAR", pos: "D", avg: 217.7},
      {rank: 246, name: "Isaac Howard", team: "EDM", pos: "LW", avg: 231.0},
      {rank: 247, name: "Matias Maccelli", team: "TOR", pos: "LW", avg: 227.0},
      {rank: 248, name: "Warren Foegele", team: "LA", pos: "LW,RW", avg: 203.0},
      {rank: 249, name: "Oliver Bjorkstrand", team: "TB", pos: "RW", avg: 232.6},
      {rank: 250, name: "Neal Pionk", team: "WPG", pos: "D", avg: 206.5},
      {rank: 251, name: "Michael Bunting", team: "NSH", pos: "LW", avg: 221.3},
      {rank: 252, name: "Blake Coleman", team: "CGY", pos: "C,LW,RW", avg: 229.0},
      {rank: 253, name: "Jake Neighbours", team: "STL", pos: "LW,RW", avg: 232.0},
      {rank: 254, name: "Alex Laferriere", team: "LA", pos: "RW", avg: 213.5},
      {rank: 255, name: "John Klingberg", team: "SJ", pos: "D", avg: 226.7},
      {rank: 256, name: "Mikael Granlund", team: "ANA", pos: "C,LW,RW", avg: 234.3},
      {rank: 257, name: "Barrett Hayton", team: "UTA", pos: "C", avg: 229.0},
      {rank: 258, name: "Jason Zucker", team: "BUF", pos: "LW", avg: 235.0},
      {rank: 259, name: "Filip Hronek", team: "VAN", pos: "D", avg: 219.5},
      {rank: 260, name: "Charlie Lindgren", team: "WSH", pos: "G", avg: 236.0},
      {rank: 261, name: "Simon Holmstrom", team: "NYI", pos: "RW", avg: 192.0},
      {rank: 262, name: "Teuvo Teravainen", team: "CHI", pos: "LW,RW", avg: 222.0},
      {rank: 263, name: "Matthew Schaefer", team: "NYI", pos: "D", avg: 233.3},
      {rank: 264, name: "Michael Misa", team: "SJ", pos: "C", avg: 225.5},
      {rank: 265, name: "Samuel Ersson", team: "PHI", pos: "G", avg: 225.5},
      {rank: 266, name: "Kris Letang", team: "PIT", pos: "D", avg: 227.0},
      {rank: 267, name: "Tristan Jarry", team: "PIT", pos: "G", avg: 235.3},
      {rank: 268, name: "Mats Zuccarello", team: "MIN", pos: "RW", avg: 236.0},
      {rank: 269, name: "Maxim Shabanov", team: "NYI", pos: "RW", avg: 240.5},
      {rank: 270, name: "Bobby McMann", team: "TOR", pos: "LW", avg: 238.0},
      {rank: 271, name: "Yegor Sharangovich", team: "CGY", pos: "C,LW,RW", avg: 213.0},
      {rank: 272, name: "Bowen Byram", team: "BUF", pos: "D", avg: 232.5},
      {rank: 273, name: "Casey Mittelstadt", team: "BOS", pos: "C", avg: 239.0},
      {rank: 274, name: "William Karlsson", team: "VGK", pos: "C", avg: 244.0},
      {rank: 275, name: "Mattias Ekholm", team: "EDM", pos: "D", avg: 234.0},
      {rank: 276, name: "Jake Walman", team: "EDM", pos: "D", avg: 234.0},
      {rank: 277, name: "Sean Couturier", team: "PHI", pos: "C", avg: 218.0},
      {rank: 278, name: "Mikael Backlund", team: "CGY", pos: "C", avg: 224.0},
      {rank: 279, name: "Jonathan Drouin", team: "NYI", pos: "LW,RW", avg: 238.0},
      {rank: 280, name: "Phillip Danault", team: "LA", pos: "C", avg: 225.0},
      {rank: 281, name: "Calvin Pickard", team: "EDM", pos: "G", avg: 238.5},
      {rank: 282, name: "Bobby Brink", team: "PHI", pos: "RW", avg: 228.0},
      {rank: 283, name: "Max Domi", team: "TOR", pos: "C,LW", avg: 240.5},
      {rank: 284, name: "Tyson Foerster", team: "PHI", pos: "LW,RW", avg: 246.0},
      {rank: 285, name: "Justin Faulk", team: "STL", pos: "D", avg: 231.0},
      {rank: 286, name: "Owen Power", team: "BUF", pos: "D", avg: 231.0},
      {rank: 287, name: "Brent Burns", team: "COL", pos: "D", avg: 232.0},
      {rank: 288, name: "Connor Zary", team: "CGY", pos: "C,LW,RW", avg: 232.0},
      {rank: 289, name: "Evan Rodrigues", team: "FLA", pos: "C,LW,RW", avg: 233.0},
      {rank: 290, name: "Nick Paul", team: "TB", pos: "C,LW", avg: 234.0},
      {rank: 291, name: "Zack Bolduc", team: "MTL", pos: "RW", avg: 246.0},
      {rank: 292, name: "Stefan Noesen", team: "NJ", pos: "LW,RW", avg: 239.0},
      {rank: 293, name: "Dan Vladar", team: "PHI", pos: "G", avg: 241.0},
      {rank: 294, name: "Trevor Moore", team: "LA", pos: "LW,RW", avg: 241.0},
      {rank: 295, name: "Jordan Eberle", team: "SEA", pos: "RW", avg: 248.0},
      {rank: 296, name: "Colton Parayko", team: "STL", pos: "D", avg: 247.0},
      {rank: 297, name: "Luke Evangelista", team: "NSH", pos: "RW", avg: 247.0},
      {rank: 298, name: "Brandt Clarke", team: "LA", pos: "D", avg: 248.3},
      {rank: 299, name: "Mavrik Bourque", team: "DAL", pos: "C,RW", avg: 248.0},
      {rank: 300, name: "Danila Yurov", team: "MIN", pos: "RW", avg: 248.0}
    ];
  </script>

<style>
    :root {
      --pos-f-bg: rgba(220, 38, 38, 0.15); /* Red-500 @ 15% */
      --pos-d-bg: rgba(59, 130, 246, 0.15); /* Blue-500 @ 15% */
      --pos-g-bg: rgba(234, 179, 8, 0.15); /* Yellow-500 @ 15% */
    }
    .pos-f { background-color: var(--pos-f-bg); }
    .pos-d { background-color: var(--pos-d-bg); }
    .pos-g { background-color: var(--pos-g-bg); }

    /* Position-based cell coloring */
    #keepersTable td.cell-forward { 
      background-color: rgba(220, 38, 38, 0.4) !important; 
      border-left: 3px solid #dc2626 !important;
    }
    #keepersTable td.cell-defense { 
      background-color: rgba(59, 130, 246, 0.4) !important; 
      border-left: 3px solid #3b82f6 !important;
    }
    #keepersTable td.cell-goalie { 
      background-color: rgba(234, 179, 8, 0.4) !important; 
      border-left: 3px solid #eab308 !important;
    }
    
    /* Alternative approach - more specific selectors */
    table#keepersTable tbody tr td.cell-forward {
      background-color: rgba(220, 38, 38, 0.5) !important;
      border-left: 4px solid #dc2626 !important;
    }
    table#keepersTable tbody tr td.cell-defense {
      background-color: rgba(59, 130, 246, 0.5) !important;
      border-left: 4px solid #3b82f6 !important;
    }
    table#keepersTable tbody tr td.cell-goalie {
      background-color: rgba(234, 179, 8, 0.5) !important;
      border-left: 4px solid #eab308 !important;
    }
    
    /* Team Header Stats */
    .team-header-stats {
      display: flex; align-items: center; gap: 0.5rem;
      font-size: 0.75rem; color: #9ca3af;
    }
    .team-progress-ring {
      width: 20px; height: 20px; border-radius: 50%;
      background: conic-gradient(#3b82f6 0deg, #374151 0deg);
      display: flex; align-items: center; justify-content: center;
      font-size: 0.6rem; font-weight: bold; color: white;
    }
    .position-count {
      display: inline-flex; align-items: center; gap: 0.25rem;
      padding: 0.125rem 0.25rem; border-radius: 0.25rem;
      background: rgba(55, 65, 81, 0.5); font-size: 0.65rem;
    }
    .pos-count-f { color: #f87171; }
    .pos-count-d { color: #60a5fa; }
    .pos-count-g { color: #facc15; }
    
    /* Current Pick Highlighting */
    .current-pick { background-color: rgba(251, 191, 36, 0.2) !important; border: 2px solid #fbbf24 !important; }
    
    /* Team Roster View */
    .team-roster-item {
      display: flex; align-items: center; padding: 0.5rem 0;
      border-bottom: 1px solid #374151; font-size: 0.875rem;
    }
    .team-roster-item:last-child { border-bottom: none; }
    .team-name { font-weight: 600; color: #e5e7eb; margin-bottom: 0.5rem; }
    .position-count { font-size: 0.75rem; color: #9ca3af; margin-left: auto; }

    .cell { padding: 0.5rem 0.25rem; border-bottom: 1px solid #374151; text-align: center; }
    .row:hover .cell { background-color: rgba(31, 41, 55, 0.5); }

    .input-wrapper { position: relative; display: flex; align-items: center; }
    .input-wrapper:focus-within {
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
        border-radius: 0.25rem;
    }

    .player-input {
      background-color: transparent; border: none; color: white;
      font-weight: 500; font-size: 0.875rem; width: 100%;
      text-align: center; outline: none; border-radius: 0.25rem;
      padding: 0.25rem 1.25rem 0.25rem 0.5rem; /* Make space for clear button */
    }
    .placeholder-input {
      background-color: transparent; border: none; font-style: italic;
      font-size: 0.875rem; width: 100%; text-align: center;
      color: #6b7280; outline: none; border-radius: 0.25rem;
      padding: 0.25rem 0.5rem;
    }

    .clear-btn {
        position: absolute; right: 4px; top: 50%;
        transform: translateY(-50%);
        color: #9ca3af; cursor: pointer; display: none;
        font-size: 0.8rem; padding: 0.1rem;
    }
    .input-wrapper:hover .clear-btn { display: block; }
    .clear-btn:hover { color: #ef4444; }

    .th-sortable {
      width: 10%; padding: 1.25rem 1rem; text-align: center;
      font-weight: 600; color: #e5e7eb; cursor: pointer;
      transition: background-color 0.2s;
    }
    .th-sortable:hover { background-color: #374151; }
    .thead-wrap { display: flex; flex-direction: column; align-items: center; gap: 0.25rem; }
    .thead-icon { color: #6b7280; font-size: 0.75rem; }
    #keepersTable, #keepersTable tbody, #keepersTable td { background-color: #111827 !important; }

    .player-selector { position: relative; display: inline-block; width: 100%; }
    .player-dropdown {
      position: fixed; background: #1f2937; border: 1px solid #374151;
      border-radius: 0.5rem; max-height: 250px; overflow-y: auto;
      z-index: 10001; display: none; pointer-events: auto;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }
    .player-option {
      padding: 0.5rem 0.75rem; cursor: pointer;
      border-bottom: 1px solid #374151; color: #e5e7eb;
      font-size: 0.875rem; display: flex; align-items: center;
    }
    .player-option:hover, .player-option.highlighted { 
      background-color: #374151; 
      transform: translateX(2px);
      transition: all 0.1s ease;
    }
    .player-option.highlighted {
      background-color: #3b82f6;
      color: white;
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
    }
    .player-option.disabled {
      color: #6b7280; text-decoration: line-through; cursor: not-allowed;
    }
    .player-option.disabled:hover { background-color: #1f2937; }
    .player-option:last-child { border-bottom: none; }
    .player-rank { color: #9ca3af; font-size: 0.75rem; min-width: 35px; text-align: left; }
    .player-team { color: #6b7280; font-size: 0.75rem; margin-left: 0.5rem; }
    .player-pos {
        font-size: 0.7rem; font-weight: bold; border-radius: 0.25rem;
        padding: 0.1rem 0.3rem; margin-left: auto;
    }
    .pos-f-text { color: #f87171; border: 1px solid #f87171; }
    .pos-d-text { color: #60a5fa; border: 1px solid #60a5fa; }
    .pos-g-text { color: #facc15; border: 1px solid #facc15; }

    /* Cell-level meta (team/position) */
    .cell-meta { margin-top: 0.2rem; font-size: 0.7rem; display: flex; align-items: center; justify-content: center; gap: 0.4rem; }

    /* Main Tab Styles */
    .main-tab-button {
      padding: 0.75rem 1.5rem; border: none;
      background: #374151; color: #9ca3af; border-radius: 0.5rem;
      font-size: 0.875rem; font-weight: 500; cursor: pointer;
      transition: all 0.2s; display: flex; align-items: center;
    }
    .main-tab-button.active {
      background: #3b82f6; color: white;
    }
    .main-tab-button:hover:not(.active) {
      background: #4b5563; color: #e5e7eb;
    }
    .main-tab-content {
      min-height: calc(100vh - 300px);
    }
    .side-panel-content { overflow-y: auto; flex: 1; }
    
    /* Floating Action Bar */
    .floating-actions {
      position: fixed; bottom: 1rem; right: 1rem;
      display: flex; gap: 0.5rem; z-index: 1000;
      background: rgba(17, 24, 39, 0.95); backdrop-filter: blur(8px);
      border: 1px solid #374151; border-radius: 0.75rem;
      padding: 0.75rem; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
    }
    .floating-btn {
      width: 40px; height: 40px; border-radius: 50%;
      border: none; background: #374151; color: #e5e7eb;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; transition: all 0.2s; font-size: 0.875rem;
    }
    .floating-btn:hover {
      background: #4b5563; transform: scale(1.05);
    }
    .floating-btn.active {
      background: #3b82f6; color: white;
    }
    
    /* Draft Prompts */
    .draft-prompt {
      background: linear-gradient(135deg, #374151 0%, #4b5563 100%);
      border: 1px solid #4b5563;
      border-radius: 0.5rem;
      padding: 0.75rem;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
    }
    .draft-prompt:hover {
      background: linear-gradient(135deg, #4b5563 0%, #6b7280 100%);
      border-color: #3b82f6;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }
    .draft-prompt-header {
      display: flex; align-items: center; gap: 0.5rem;
      margin-bottom: 0.5rem;
    }
    .draft-prompt-icon {
      font-size: 1rem; color: #3b82f6;
    }
    .draft-prompt-title {
      font-weight: 600; color: white; font-size: 0.875rem;
    }
    .draft-prompt-description {
      color: #9ca3af; font-size: 0.75rem; line-height: 1.4;
    }
    .draft-prompt-count {
      position: absolute; top: 0.5rem; right: 0.5rem;
      background: rgba(59, 130, 246, 0.2); color: #60a5fa;
      padding: 0.125rem 0.375rem; border-radius: 0.25rem;
      font-size: 0.65rem; font-weight: 600;
    }
    
    
    /* Auto-save indicator */
    /* Auto-save indicator removed */
    
    /* Mobile responsive */
    @media (max-width: 1024px) {
      .floating-actions {
        bottom: 0.5rem; right: 0.5rem;
      }
      .team-header-stats {
        font-size: 0.7rem;
      }
      .team-progress-ring {
        width: 18px; height: 18px; font-size: 0.55rem;
      }
      .main-tab-button {
        padding: 0.5rem 0.75rem;
        font-size: 0.75rem;
      }
      
      /* Header responsive */
      .flex.items-center.justify-between.mb-4 {
        flex-direction: column;
        align-items: flex-start;
        gap: 1rem;
      }
      .flex.items-center.gap-4 {
        flex-wrap: wrap;
        gap: 0.5rem;
      }
      
      /* Tablet 3-column layout */
      .grid.grid-cols-1.lg\\:grid-cols-6 {
        grid-template-columns: repeat(3, 1fr);
        gap: 1rem;
      }
    }
    
    @media (max-width: 768px) {
      .flex.h-screen {
        flex-direction: column;
      }
      .floating-actions {
        position: relative; bottom: auto; right: auto;
        margin: 1rem; border-radius: 0.5rem;
      }
      .floating-btn {
        width: 36px; height: 36px; font-size: 0.75rem;
      }
      
      /* Mobile Tab Layout */
      .main-tab-button {
        padding: 0.375rem 0.5rem;
        font-size: 0.7rem;
        flex: 1;
        min-width: 0;
      }
      
      /* Mobile 6-column layout */
      .grid.grid-cols-1.lg\\:grid-cols-6 {
        grid-template-columns: 1fr;
        gap: 1rem;
      }
      
      /* Mobile table improvements */
      #keepersTable {
        font-size: 0.75rem;
      }
      .th-sortable {
        padding: 0.75rem 0.5rem;
      }
      .team-header-stats {
        display: none; /* Hide stats on mobile to save space */
      }
      .thead-wrap span {
        font-size: 0.7rem;
      }
      
      /* Mobile tab improvements */
      .tab-buttons {
        flex-wrap: wrap;
        gap: 0.125rem;
      }
      .tab-button {
        font-size: 0.65rem;
        padding: 0.375rem 0.5rem;
        flex: 1;
        min-width: 0;
      }
      
      
      /* Mobile prompt improvements */
      .grid.grid-cols-2.md\\:grid-cols-3.lg\\:grid-cols-6 {
        grid-template-columns: repeat(2, 1fr);
        gap: 0.5rem;
      }
      
      /* Tablet prompt layout */
      @media (min-width: 768px) {
        .grid.grid-cols-2.md\\:grid-cols-3.lg\\:grid-cols-6 {
          grid-template-columns: repeat(3, 1fr);
          gap: 0.75rem;
        }
      }
      
      /* Desktop prompt layout */
      @media (min-width: 1024px) {
        .grid.grid-cols-2.md\\:grid-cols-3.lg\\:grid-cols-6 {
          grid-template-columns: repeat(6, 1fr);
          gap: 0.75rem;
        }
      }
      
      /* Mobile header improvements */
      .flex.items-center.space-x-4.text-sm {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.5rem;
      }
      .flex.items-center.text-gray-400 {
        font-size: 0.75rem;
      }
    }
    
    @media (max-width: 480px) {
      .px-4.py-8 {
        padding: 1rem 0.5rem;
      }
      .p-6 {
        padding: 1rem;
      }
      .text-3xl {
        font-size: 1.5rem;
      }
      .text-xl {
        font-size: 1.125rem;
      }
      
      /* Ultra-mobile table */
      #keepersTable {
        font-size: 0.65rem;
      }
      .th-sortable {
        padding: 0.5rem 0.25rem;
      }
      .thead-wrap span {
        font-size: 0.6rem;
      }
      
      /* Hide some columns on very small screens */
      .th-sortable:nth-child(n+8) {
        display: none;
      }
      #keepersTable td:nth-child(n+8) {
        display: none;
      }
    }
    .best-available-player {
      display: flex; align-items: center; padding: 0.4rem 0;
      border-bottom: 1px solid #374151; font-size: 0.875rem;
    }
    .best-available-player:last-child { border-bottom: none; }

    #keepersTable td { overflow: visible !important; position: relative; }
    
    /* Enhanced table styling */
    .table-row-even { background-color: rgba(31, 41, 55, 0.3); }
    .table-row-odd { background-color: rgba(17, 24, 39, 0.5); }
    .current-pick-row { background-color: rgba(251, 191, 36, 0.1) !important; }
    /* Draft phase indicators removed */
    
    /* Tooltip styles */
    .tooltip {
      position: relative; cursor: help;
    }
    .tooltip::after {
      content: attr(data-tooltip);
      position: absolute; bottom: 100%; left: 50%;
      transform: translateX(-50%); background: #1f2937;
      color: white; padding: 0.5rem; border-radius: 0.375rem;
      font-size: 0.75rem; white-space: nowrap;
      opacity: 0; pointer-events: none; transition: opacity 0.2s;
      z-index: 1000; border: 1px solid #374151;
    }
    .tooltip:hover::after {
      opacity: 1;
    }
  </style>
</head>
<body class="min-h-screen bg-fantasy-dark text-gray-100">
  <div class="flex h-screen">
    <!-- Main Content Area -->
    <div class="flex-1 overflow-auto px-4 py-8">
      <div class="bg-fantasy-card rounded-2xl shadow-2xl p-6 border border-gray-800">
      <!-- Main App Tabs -->
      <div class="mb-6">
        <div class="flex items-center justify-between mb-4">
          <h1 class="text-3xl font-bold text-white">Fantasy Keepers Table — 2025</h1>
          <div class="flex items-center gap-4">
            <!-- Draft Info -->
            <div class="flex items-center space-x-4 text-sm">
              <div class="flex items-center text-gray-400">
                <i class="fas fa-info-circle mr-2"></i>Non-snake draft • Luke has 1st pick
              </div>
              <div class="flex items-center text-gray-400">
                <i class="fas fa-users mr-2"></i>25 rounds total • 6-10 keepers per team
              </div>
              <div class="bg-gray-700 rounded-lg px-3 py-2">
                <span class="text-sm text-gray-400">Total Players:</span>
                <span class="ml-2 font-semibold text-white" id="playerCount">0</span>
              </div>
              <div class="bg-gray-700 rounded-lg px-3 py-2">
                <span class="text-sm text-gray-400">Draft Progress:</span>
                <span class="ml-2 font-semibold text-white" id="draftProgress">0%</span>
              </div>
              <div class="bg-gray-700 rounded-lg px-3 py-2">
                <span class="text-sm text-gray-400">Current Pick:</span>
                <span class="ml-2 font-semibold text-white" id="currentPickDisplay">1</span>
              </div>
            </div>
          <button id="resetButton" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
            <i class="fas fa-sync-alt mr-2"></i>Reset Draft
          </button>
          </div>
        </div>
        
        <!-- Main Navigation Tabs -->
        <div class="flex gap-2 mb-4 flex-wrap">
          <button class="main-tab-button active" data-main-tab="draft-board">
            <i class="fas fa-table mr-2"></i>Draft Board
          </button>
          <button class="main-tab-button" data-main-tab="best-available">
            <i class="fas fa-trophy mr-2"></i>Best Available
          </button>
          <button class="main-tab-button" data-main-tab="position-analysis">
            <i class="fas fa-chart-pie mr-2"></i>Position Analysis
          </button>
          <button class="main-tab-button" data-main-tab="team-rosters">
            <i class="fas fa-users mr-2"></i>Team Rosters
          </button>
          <button class="main-tab-button" data-main-tab="draft-trends">
            <i class="fas fa-trending-up mr-2"></i>Draft Trends
          </button>
      </div>

        <!-- Draft Progress Bar -->
        <div class="mb-4">
          <div class="w-full bg-gray-700 rounded-full h-2">
            <div class="progress-bar bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
          </div>
          <div class="text-xs text-gray-400 mt-1">Draft Progress: <span id="progressText">0 of 250 picks</span></div>
        </div>
      </div>

      <!-- Main Tab Content -->
      <div id="main-tab-content">
        <!-- Draft Board Tab -->
        <div id="main-tab-draft-board" class="main-tab-content">
      <!-- Smart Draft Prompts -->
      <div class="mb-4 p-4 bg-gray-800 rounded-lg">
        <div class="flex items-center justify-between mb-3">
          <h3 class="text-lg font-semibold text-white">💡 Draft Suggestions</h3>
          <div id="draftContext" class="text-sm text-gray-400"></div>
        </div>
            
        <!-- Contextual Prompts -->
        <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-3" id="draftPrompts">
          <!-- Prompts will be dynamically generated here -->
        </div>
      </div>

      <div class="border border-gray-700 rounded-xl bg-gray-900/50">
        <table class="w-full table-fixed" id="keepersTable">
          <thead class="bg-gray-800 sticky top-0 z-10">
            <tr>
                  <th class="th-sortable" data-column="0" style="width: 6%;"><div class="thead-wrap"><span>Round</span><i class="fas fa-sort thead-icon"></i></div></th>
                  <th class="th-sortable" data-column="1" style="width: 9.4%;"><div class="thead-wrap"><span>Luke (1st)</span><div class="team-header-stats" id="team-stats-1"><div class="team-progress-ring" id="progress-1">0</div><div class="position-count"><span class="pos-count-f" id="c-1">0</span><span class="pos-count-f" id="lw-1">0</span><span class="pos-count-f" id="rw-1">0</span><span class="pos-count-d" id="d-1">0</span><span class="pos-count-g" id="g-1">0</span></div></div><i class="fas fa-sort thead-icon"></i></div></th>
                  <th class="th-sortable" data-column="2" style="width: 9.4%;"><div class="thead-wrap"><span>Dinesh (2nd)</span><div class="team-header-stats" id="team-stats-2"><div class="team-progress-ring" id="progress-2">0</div><div class="position-count"><span class="pos-count-f" id="c-2">0</span><span class="pos-count-f" id="lw-2">0</span><span class="pos-count-f" id="rw-2">0</span><span class="pos-count-d" id="d-2">0</span><span class="pos-count-g" id="g-2">0</span></div></div><i class="fas fa-sort thead-icon"></i></div></th>
                  <th class="th-sortable" data-column="3" style="width: 9.4%;"><div class="thead-wrap"><span>Glis (3rd)</span><div class="team-header-stats" id="team-stats-3"><div class="team-progress-ring" id="progress-3">0</div><div class="position-count"><span class="pos-count-f" id="c-3">0</span><span class="pos-count-f" id="lw-3">0</span><span class="pos-count-f" id="rw-3">0</span><span class="pos-count-d" id="d-3">0</span><span class="pos-count-g" id="g-3">0</span></div></div><i class="fas fa-sort thead-icon"></i></div></th>
                  <th class="th-sortable" data-column="4" style="width: 9.4%;"><div class="thead-wrap"><span>Toph (4th)</span><div class="team-header-stats" id="team-stats-4"><div class="team-progress-ring" id="progress-4">0</div><div class="position-count"><span class="pos-count-f" id="c-4">0</span><span class="pos-count-f" id="lw-4">0</span><span class="pos-count-f" id="rw-4">0</span><span class="pos-count-d" id="d-4">0</span><span class="pos-count-g" id="g-4">0</span></div></div><i class="fas fa-sort thead-icon"></i></div></th>
                  <th class="th-sortable" data-column="5" style="width: 9.4%;"><div class="thead-wrap"><span>Geoff (5th)</span><div class="team-header-stats" id="team-stats-5"><div class="team-progress-ring" id="progress-5">0</div><div class="position-count"><span class="pos-count-f" id="c-5">0</span><span class="pos-count-f" id="lw-5">0</span><span class="pos-count-f" id="rw-5">0</span><span class="pos-count-d" id="d-5">0</span><span class="pos-count-g" id="g-5">0</span></div></div><i class="fas fa-sort thead-icon"></i></div></th>
                  <th class="th-sortable" data-column="6" style="width: 9.4%;"><div class="thead-wrap"><span>Whidds (6th)</span><div class="team-header-stats" id="team-stats-6"><div class="team-progress-ring" id="progress-6">0</div><div class="position-count"><span class="pos-count-f" id="c-6">0</span><span class="pos-count-f" id="lw-6">0</span><span class="pos-count-f" id="rw-6">0</span><span class="pos-count-d" id="d-6">0</span><span class="pos-count-g" id="g-6">0</span></div></div><i class="fas fa-sort thead-icon"></i></div></th>
                  <th class="th-sortable" data-column="7" style="width: 9.4%;"><div class="thead-wrap"><span>Dooger (7th)</span><div class="team-header-stats" id="team-stats-7"><div class="team-progress-ring" id="progress-7">0</div><div class="position-count"><span class="pos-count-f" id="c-7">0</span><span class="pos-count-f" id="lw-7">0</span><span class="pos-count-f" id="rw-7">0</span><span class="pos-count-d" id="d-7">0</span><span class="pos-count-g" id="g-7">0</span></div></div><i class="fas fa-sort thead-icon"></i></div></th>
                  <th class="th-sortable" data-column="8" style="width: 9.4%;"><div class="thead-wrap"><span>Bendy (8th)</span><div class="team-header-stats" id="team-stats-8"><div class="team-progress-ring" id="progress-8">0</div><div class="position-count"><span class="pos-count-f" id="c-8">0</span><span class="pos-count-f" id="lw-8">0</span><span class="pos-count-f" id="rw-8">0</span><span class="pos-count-d" id="d-8">0</span><span class="pos-count-g" id="g-8">0</span></div></div><i class="fas fa-sort thead-icon"></i></div></th>
                  <th class="th-sortable" data-column="9" style="width: 9.4%;"><div class="thead-wrap"><span>Blake (9th)</span><div class="team-header-stats" id="team-stats-9"><div class="team-progress-ring" id="progress-9">0</div><div class="position-count"><span class="pos-count-f" id="c-9">0</span><span class="pos-count-f" id="lw-9">0</span><span class="pos-count-f" id="rw-9">0</span><span class="pos-count-d" id="d-9">0</span><span class="pos-count-g" id="g-9">0</span></div></div><i class="fas fa-sort thead-icon"></i></div></th>
                  <th class="th-sortable" data-column="10" style="width: 9.4%;"><div class="thead-wrap"><span>Deke (10th)</span><div class="team-header-stats" id="team-stats-10"><div class="team-progress-ring" id="progress-10">0</div><div class="position-count"><span class="pos-count-f" id="c-10">0</span><span class="pos-count-f" id="lw-10">0</span><span class="pos-count-f" id="rw-10">0</span><span class="pos-count-d" id="d-10">0</span><span class="pos-count-g" id="g-10">0</span></div></div><i class="fas fa-sort thead-icon"></i></div></th>
            </tr>
          </thead>
          <tbody id="tableBody"></tbody>
        </table>
      </div>
        </div>
        
        <!-- Best Available Tab -->
        <div id="main-tab-best-available" class="main-tab-content hidden">
          <div class="bg-gray-800 rounded-lg p-6">
            <h2 class="text-2xl font-bold text-white mb-6">🏆 Best Available Players</h2>
            <div class="grid grid-cols-1 lg:grid-cols-6 gap-4">
              <!-- Overall Column -->
              <div class="bg-gray-700 rounded-lg p-4">
                <h3 class="text-lg font-semibold text-white mb-4 flex items-center">
                  <i class="fas fa-trophy mr-2 text-yellow-400"></i>Overall
                </h3>
                <div id="overallPlayers" class="space-y-2">
                  <p class="text-gray-400 text-sm">Loading...</p>
    </div>
    </div>

              <!-- Centers Column -->
              <div class="bg-gray-700 rounded-lg p-4">
                <h3 class="text-lg font-semibold text-white mb-4 flex items-center">
                  <i class="fas fa-circle mr-2 text-red-400"></i>Centers
                </h3>
                <div id="centerPlayers" class="space-y-2">
                  <p class="text-gray-400 text-sm">Loading...</p>
                </div>
              </div>
              
              <!-- Left Wings Column -->
              <div class="bg-gray-700 rounded-lg p-4">
                <h3 class="text-lg font-semibold text-white mb-4 flex items-center">
                  <i class="fas fa-arrow-left mr-2 text-orange-400"></i>Left Wings
                </h3>
                <div id="leftWingPlayers" class="space-y-2">
                  <p class="text-gray-400 text-sm">Loading...</p>
      </div>
    </div>
    
              <!-- Right Wings Column -->
              <div class="bg-gray-700 rounded-lg p-4">
                <h3 class="text-lg font-semibold text-white mb-4 flex items-center">
                  <i class="fas fa-arrow-right mr-2 text-pink-400"></i>Right Wings
                </h3>
                <div id="rightWingPlayers" class="space-y-2">
                  <p class="text-gray-400 text-sm">Loading...</p>
                </div>
    </div>

              <!-- Defense Column -->
              <div class="bg-gray-700 rounded-lg p-4">
                <h3 class="text-lg font-semibold text-white mb-4 flex items-center">
                  <i class="fas fa-shield-alt mr-2 text-blue-400"></i>Defense
                </h3>
                <div id="defensePlayers" class="space-y-2">
                  <p class="text-gray-400 text-sm">Loading...</p>
                </div>
    </div>
    
              <!-- Goalies Column -->
              <div class="bg-gray-700 rounded-lg p-4">
                <h3 class="text-lg font-semibold text-white mb-4 flex items-center">
                  <i class="fas fa-mask mr-2 text-yellow-400"></i>Goalies
                </h3>
                <div id="goaliePlayers" class="space-y-2">
        <p class="text-gray-400 text-sm">Loading...</p>
                </div>
              </div>
      </div>
    </div>
  </div>

        <!-- Position Analysis Tab -->
        <div id="main-tab-position-analysis" class="main-tab-content hidden">
          <div class="bg-gray-800 rounded-lg p-6">
            <h2 class="text-2xl font-bold text-white mb-6">📊 Position Analysis</h2>
            <div id="fullScreenPositionAnalysis">
              <p class="text-gray-400 text-sm">Position analysis will appear here...</p>
            </div>
          </div>
    </div>
    
        <!-- Team Rosters Tab -->
        <div id="main-tab-team-rosters" class="main-tab-content hidden">
          <div class="bg-gray-800 rounded-lg p-6">
            <h2 class="text-2xl font-bold text-white mb-6">👥 Team Rosters</h2>
            <div id="fullScreenTeamRosters">
              <p class="text-gray-400 text-sm">Team rosters will appear here...</p>
            </div>
          </div>
        </div>
        
        <!-- Draft Trends Tab -->
        <div id="main-tab-draft-trends" class="main-tab-content hidden">
          <div class="bg-gray-800 rounded-lg p-6">
            <h2 class="text-2xl font-bold text-white mb-6">📈 Draft Trends</h2>
            <div id="fullScreenDraftTrends">
              <p class="text-gray-400 text-sm">Draft trends will appear here...</p>
      </div>
    </div>
  </div>
        
                </div>
    </div>
    </div>

  <div id="dropdownPortal" style="position: fixed; top: 0; left: 0; z-index: 10000; pointer-events: none;"></div>

  
  <!-- Floating Action Bar -->
  <div class="floating-actions">
    <button class="floating-btn tooltip" data-tooltip="Undo" id="floatingUndoBtn" disabled>
      <i class="fas fa-undo"></i>
    </button>
    <button class="floating-btn tooltip" data-tooltip="Redo" id="floatingRedoBtn" disabled>
      <i class="fas fa-redo"></i>
    </button>
    <button class="floating-btn tooltip" data-tooltip="Export Draft" id="floatingExportBtn">
      <i class="fas fa-download"></i>
    </button>
  </div>
  
  <!-- Auto-save Indicator removed -->

  <script>
    // --- CONFIGURATION & DATA ---
    const DRAFT_YEAR = 2025;
    const STORAGE_KEY = `fantasyDraft_${DRAFT_YEAR}`;
    const owners = ['Luke (1st)', 'Dinesh (2nd)', 'Glis (3rd)', 'Toph (4th)', 'Geoff (5th)', 'Whidds (6th)', 'Dooger (7th)', 'Bendy (8th)', 'Blake (9th)', 'Deke (10th)'];
    const numRounds = 25;
    
    
    // League Settings: Keeper Tight League
    const LEAGUE_SETTINGS = {
      type: 'Head-to-Head Points',
      teams: 10,
      rosterPositions: {
        centers: 4,
        leftWings: 4, 
        rightWings: 4,
        defensemen: 6,
        goalies: 2,
        bench: 5,
        irPlus: 4,
        na: 2
      },
      pointStructure: {
        offensive: {
          goals: 3.0,
          assists: 2.0,
          plusMinus: 1.0,
          powerplayGoals: 0.5,
          powerplayAssists: 0.5,
          gameWinningGoals: 0.5,
          shotsOnGoal: 0.4
        },
        goaltending: {
          wins: 3.0,
          goalsAgainst: -1.0,
          saves: 0.2,
          shutouts: 2.0
        }
      }
    };
    const initialPrefilledData = {
        1: ["Connor Bedard", "Matt Boldy", "Adrian Kempe", "Sidney Crosby", "Auston Matthews", "Nikita Kucherov", "Kyle Connor", "Connor McDavid", "Cale Makar", "Leon Draisaitl"],
        2: ["Macklin Celebrini", "Lucas Raymond", "Jordan Kyrou", "Sam Reinhart", "Connor Hellebuyck", "Jack Hughes", "Zach Werenski", "Nathan MacKinnon", "Mikko Rantanen", "David Pastrnak"],
        3: ["John Tavares", "Dylan Holloway", "Cole Caufield", "Tage Thompson", "Dustin Wolf", "Tim Stützle", "Nick Suzuki", "Jack Eichel", "William Nylander", "Mitch Marner"],
        4: ["Jason Robertson", "Quinton Byfield", "J.T. Miller", "Mark Scheifele", "Timo Meier", "Nico Hischier", "Clayton Keller", "Sebastian Aho", "Brayden Point", "Alex Ovechkin"],
        5: ["Alex DeBrincat", "Cutter Gauthier", "Jesper Bratt", "Dylan Guenther", "Bo Horvat", "", "Filip Forsberg", "Kirill Kaprizov", "Artemi Panarin", "Kirill Marchenko"],
        6: ["Adam Fantilli", "Alex Tuch", "Seth Jarvis", "Elias Pettersson", "JJ Peterka", "Martin Necas", "Dylan Larkin", "Jake Guentzel", "Victor Hedman", "Travis Konecny"],
        7: ["Brandon Hagel", "Logan Cooley", "Moritz Seider", "Evan Bouchard", "Dougie Hamilton", "Josh Morrissey", "Roope Hintz", "Brady Tkachuk", "Robert Thomas", "Matvei Michkov"],
        8: ["Aliaksei Protas", "Leo Carlsson", "Miro Heiskanen", "Mackenzie Blackwood", "Matthew Tkachuk", "", "Shea Theodore", "Quinn Hughes", "Wyatt Johnston", "Jake Sanderson"],
        9: ["Adam Fox", "Lane Hutson", "", "", "", "", "Juraj Slafkovsky", "Rasmus Dahlin", "Dylan Strome", "Jake Oettinger"],
        10: ["Adin Hill", "Logan Thompson", "", "", "", "", "Ilya Sorokin", "Thomas Harley", "Andrei Vasilevskiy", "Igor Shesterkin"],
    };
    const nameAliases = { 'jt miller': 'j.t. miller', 'tim stutzle': 'tim stützle', 'jj peterka': 'jj peterka', 'adam fantili': 'adam fantilli' };
    const positionColors = { C: 'pos-f', LW: 'pos-f', RW: 'pos-f', D: 'pos-d', G: 'pos-g' };
    const positionTextColors = { C: 'pos-f-text', LW: 'pos-f-text', RW: 'pos-f-text', D: 'pos-d-text', G: 'pos-g-text' };

    // --- GLOBAL STATE & UTILITIES ---
    let selectedPlayers = new Set();
    let activeDropdown = null;
    let currentTab = 'best-available';
    let currentMainTab = 'draft-board';
    let autoSaveTimeout = null;
    
    function normalizeName(name) {
        const normalized = name.toLowerCase().replace(/[^\w\s]/g, '').replace(/\s+/g, ' ').trim();
        return nameAliases[normalized] || normalized;
    }
    const playersByName = new Map(playerRankings.map(p => [normalizeName(p.name), p]));
    function findPlayerByName(inputName) {
        return inputName ? playersByName.get(normalizeName(inputName)) : undefined;
    }
    function getPlayerPrimaryPosition(player) {
        if (!player || !player.pos) return null;
        if (player.pos.includes('G')) return 'G';
        if (player.pos.includes('D')) return 'D';
        if (player.pos.includes('C')) return 'C';
        if (player.pos.includes('LW')) return 'LW';
        if (player.pos.includes('RW')) return 'RW';
        return 'C'; // Default fallback
    }

    // --- DRAFT PROGRESS TRACKING ---
    function updateDraftProgress() {
        const totalPossiblePicks = numRounds * owners.length;
        
        // Count only players actually placed in draft positions (not just selected)
        let actualDraftPicks = 0;
        document.querySelectorAll('#tableBody .player-input').forEach(input => {
            if (input.value.trim()) {
                actualDraftPicks++;
            }
        });
        
        draftStats.totalPicks = actualDraftPicks;
        draftStats.draftProgress = Math.round((draftStats.totalPicks / totalPossiblePicks) * 100);
        
        // Use the corrected getCurrentPickNumber function instead of draftStats.totalPicks + 1
        const currentPickNumber = getCurrentPickNumber();
        
        document.getElementById('draftProgress').textContent = `${draftStats.draftProgress}%`;
        document.getElementById('currentPickDisplay').textContent = currentPickNumber;
        document.getElementById('progressText').textContent = `${draftStats.totalPicks} of ${totalPossiblePicks} picks`;
        
        // Update progress bar
        const progressBar = document.querySelector('.progress-bar');
        if (progressBar) {
            progressBar.style.width = `${draftStats.draftProgress}%`;
        }
        
        // Update team header progress rings
        updateTeamHeaderStats();
    }
    
    function updateTeamHeaderStats() {
        const balances = analyzePositionBalance();
        
        owners.forEach((owner, index) => {
            const balance = balances[owner];
            const teamIndex = index + 1;
            
            // Update progress ring
            const progressRing = document.getElementById(`progress-${teamIndex}`);
            if (progressRing) {
                const progress = Math.round((balance.total / numRounds) * 100);
                progressRing.textContent = progress;
                progressRing.style.background = `conic-gradient(#3b82f6 ${progress * 3.6}deg, #374151 0deg)`;
            }
            
            // Update position counts
            document.getElementById(`c-${teamIndex}`).textContent = balance.C;
            document.getElementById(`lw-${teamIndex}`).textContent = balance.LW;
            document.getElementById(`rw-${teamIndex}`).textContent = balance.RW;
            document.getElementById(`d-${teamIndex}`).textContent = balance.D;
            document.getElementById(`g-${teamIndex}`).textContent = balance.G;
        });
    }

    // --- POSITION BALANCE ANALYSIS ---
    function analyzePositionBalance() {
        const teamBalances = {};
        
        // Initialize team balances
        owners.forEach(owner => {
            teamBalances[owner] = { C: 0, LW: 0, RW: 0, D: 0, G: 0, total: 0 };
        });
        
        // Collect all players by team first
        const teamPlayers = {};
        owners.forEach(owner => {
            teamPlayers[owner] = [];
        });
        
        document.querySelectorAll('#tableBody .player-input').forEach(input => {
            if (input.value.trim()) {
                const player = findPlayerByName(input.value);
                if (player) {
                    const row = input.closest('tr');
                    const colIndex = input.closest('td').cellIndex - 1; // -1 for round column
                    const owner = owners[colIndex];
                    if (teamPlayers[owner]) {
                        teamPlayers[owner].push(player);
                    }
                }
            }
        });
        
        // Intelligently assign each player to their best position
        owners.forEach(owner => {
            const players = teamPlayers[owner];
            const balance = teamBalances[owner];
            
            // Sort players by draft order (earlier picks get priority for position assignment)
            players.sort((a, b) => a.rank - b.rank);
            
            players.forEach(player => {
                const eligiblePositions = [];
                if (player.pos.includes('C')) eligiblePositions.push('C');
                if (player.pos.includes('LW')) eligiblePositions.push('LW');
                if (player.pos.includes('RW')) eligiblePositions.push('RW');
                if (player.pos.includes('D')) eligiblePositions.push('D');
                if (player.pos.includes('G')) eligiblePositions.push('G');
                
                // Find the position with the most need
                let bestPosition = eligiblePositions[0]; // Default to first eligible
                let maxNeed = 0;
                
                eligiblePositions.forEach(pos => {
                    let required;
                    switch(pos) {
                        case 'C': required = LEAGUE_SETTINGS.rosterPositions.centers; break;
                        case 'LW': required = LEAGUE_SETTINGS.rosterPositions.leftWings; break;
                        case 'RW': required = LEAGUE_SETTINGS.rosterPositions.rightWings; break;
                        case 'D': required = LEAGUE_SETTINGS.rosterPositions.defensemen; break;
                        case 'G': required = LEAGUE_SETTINGS.rosterPositions.goalies; break;
                        default: required = 0;
                    }
                    
                    const current = balance[pos];
                    const need = required - current;
                    
                    if (need > maxNeed) {
                        maxNeed = need;
                        bestPosition = pos;
                    }
                });
                
                // Assign player to best position
                balance[bestPosition]++;
                balance.total++;
            });
        });
        
        return teamBalances;
    }

    function applyPositionBalanceWarnings() {
        // Color cells based on the player's position
        document.querySelectorAll('#tableBody tr').forEach(row => {
            row.querySelectorAll('td:not(:first-child)').forEach(cell => {
                // Remove existing position classes
                cell.classList.remove('cell-forward', 'cell-defense', 'cell-goalie');
                
                const input = cell.querySelector('input[type="text"]');
                if (input && input.value.trim()) {
                    const player = findPlayerByName(input.value);
                    if (player) {
                        const pos = getPlayerPrimaryPosition(player);
                        
                        // Add position-based cell coloring
                        if (pos === 'C' || pos === 'LW' || pos === 'RW') {
                            cell.classList.add('cell-forward');
                        } else if (pos === 'D') {
                            cell.classList.add('cell-defense');
                        } else if (pos === 'G') {
                            cell.classList.add('cell-goalie');
                        }
                    }
                }
            });
        });
    }

    // --- UNDO/REDO FUNCTIONALITY ---
    let historySaveTimeout = null;
    let pendingHistorySave = false;
    
    function saveDraftStateToHistory() {
        // Debounce history saves to prevent multiple rapid saves
        if (historySaveTimeout) {
            clearTimeout(historySaveTimeout);
        }
        
        pendingHistorySave = true;
        historySaveTimeout = setTimeout(() => {
            if (pendingHistorySave) {
                const currentState = getCurrentDraftState();
                
                // Check if state has actually changed
                const lastState = draftHistory[historyIndex];
                if (lastState && JSON.stringify(lastState) === JSON.stringify(currentState)) {
                    // State hasn't changed, don't save
                    pendingHistorySave = false;
                    return;
                }
                
                // Remove any states after current index (for branching)
                draftHistory = draftHistory.slice(0, historyIndex + 1);
                
                // Add new state
                draftHistory.push(JSON.parse(JSON.stringify(currentState)));
                historyIndex++;
                
                // Limit history size
                if (draftHistory.length > 50) {
                    draftHistory.shift();
                    historyIndex--;
                }
                
                updateUndoRedoButtons();
                pendingHistorySave = false;
            }
        }, 100); // 100ms debounce
    }
    
    function forceSaveDraftStateToHistory() {
        // Force immediate save (for initialization)
        if (historySaveTimeout) {
            clearTimeout(historySaveTimeout);
        }
        
        const currentState = getCurrentDraftState();
        
        // Remove any states after current index (for branching)
        draftHistory = draftHistory.slice(0, historyIndex + 1);
        
        // Add new state
        draftHistory.push(JSON.parse(JSON.stringify(currentState)));
        historyIndex++;
        
        // Limit history size
        if (draftHistory.length > 50) {
            draftHistory.shift();
            historyIndex--;
        }
        
        updateUndoRedoButtons();
        pendingHistorySave = false;
    }

    function getCurrentDraftState() {
        const draftData = {};
        document.querySelectorAll('#tableBody tr').forEach(row => {
            const round = parseInt(row.dataset.round);
            draftData[round] = [];
            row.querySelectorAll('input[type="text"]').forEach(input => {
                draftData[round].push(input.value);
            });
        });
        return draftData;
    }

    function restoreDraftState(draftData) {
        // Clear the selectedPlayers set first
        selectedPlayers.clear();
        
        document.querySelectorAll('#tableBody tr').forEach(row => {
            const round = parseInt(row.dataset.round);
            const picks = draftData[round] || [];
            row.querySelectorAll('input[type="text"]').forEach((input, index) => {
                const val = picks[index] || '';
                if (val === '') {
                    input.className = 'placeholder-input';
                    input.value = '';
                    input.dataset.lastValue = '';
                    input.placeholder = `Pick ${((round - 1) * owners.length) + (index + 1)}`;
                    // Clear position classes
                    input.classList.remove(...Object.values(positionColors));
                    const cellTd = input.closest('td');
                    if (cellTd) {
                        cellTd.classList.remove('cell-forward', 'cell-defense', 'cell-goalie');
                    }
                } else {
                    input.className = 'player-input';
                    input.value = val;
                    input.dataset.lastValue = val;
                    const player = findPlayerByName(val);
                    if (player) {
                        // Add to selectedPlayers set
                        selectedPlayers.add(player.name);
                        
                        const pos = getPlayerPrimaryPosition(player);
                        input.classList.add(positionColors[pos]);
                        const cellTd = input.closest('td');
                        if (cellTd) {
                            // Clear old position classes first
                            cellTd.classList.remove('cell-forward', 'cell-defense', 'cell-goalie');
                            // Add new position class
                            if (pos === 'C' || pos === 'LW' || pos === 'RW') {
                                cellTd.classList.add('cell-forward');
                            } else if (pos === 'D') {
                                cellTd.classList.add('cell-defense');
                            } else if (pos === 'G') {
                                cellTd.classList.add('cell-goalie');
                            }
                        }
                        input.title = `#${player.rank} ${player.name} (${player.team} - ${player.pos})`;
                    }
                }
            });
        });
        updateAllUI();
    }

    function undo() {
        if (historyIndex > 0) {
            // Clear any pending history saves to prevent conflicts
            if (historySaveTimeout) {
                clearTimeout(historySaveTimeout);
                pendingHistorySave = false;
            }
            
            historyIndex--;
            restoreDraftState(draftHistory[historyIndex]);
            updateUndoRedoButtons();
            updateFloatingButtonStates();
        }
    }

    function redo() {
        if (historyIndex < draftHistory.length - 1) {
            // Clear any pending history saves to prevent conflicts
            if (historySaveTimeout) {
                clearTimeout(historySaveTimeout);
                pendingHistorySave = false;
            }
            
            historyIndex++;
            restoreDraftState(draftHistory[historyIndex]);
            updateUndoRedoButtons();
            updateFloatingButtonStates();
        }
    }

    function updateUndoRedoButtons() {
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const floatingUndoBtn = document.getElementById('floatingUndoBtn');
        const floatingRedoBtn = document.getElementById('floatingRedoBtn');
        
        const canUndo = historyIndex > 0;
        const canRedo = historyIndex < draftHistory.length - 1;
        
        if (undoBtn) undoBtn.disabled = !canUndo;
        if (redoBtn) redoBtn.disabled = !canRedo;
        if (floatingUndoBtn) floatingUndoBtn.disabled = !canUndo;
        if (floatingRedoBtn) floatingRedoBtn.disabled = !canRedo;
        
        // Debug logging removed to reduce console spam
    }

    // --- CONTEXTUAL DRAFT PROMPTS ---
    function generateDraftPrompts() {
        const container = document.getElementById('draftPrompts');
        const contextEl = document.getElementById('draftContext');
        if (!container) return;
        
        const prompts = [];
        const balances = analyzePositionBalance();
        const currentPick = getCurrentPickNumber();
        const currentRound = Math.ceil(currentPick / owners.length);
        const currentOwner = owners[(currentPick - 1) % owners.length];
        
        // Update context
        if (contextEl) {
            contextEl.textContent = `Round ${currentRound} • ${currentOwner} • Pick ${currentPick}`;
        }
        
        // 1. Best Available Overall
        const availablePlayers = playerRankings.filter(p => !selectedPlayers.has(p.name));
        if (availablePlayers.length > 0) {
            const topAvailable = availablePlayers.slice(0, 3);
            prompts.push({
                icon: '🏆',
                title: 'Top Available',
                description: `${topAvailable.map(p => p.name).join(', ')}`,
                count: availablePlayers.length,
                action: () => switchMainTab('best-available')
            });
        }
        
        // 2. Position Needs Analysis
        const currentOwnerBalance = balances[currentOwner];
        if (currentOwnerBalance && currentOwnerBalance.total > 0) {
            const needs = [];
            if (currentOwnerBalance.C < LEAGUE_SETTINGS.rosterPositions.centers) {
                needs.push(`${LEAGUE_SETTINGS.rosterPositions.centers - currentOwnerBalance.C} Centers`);
            }
            if (currentOwnerBalance.LW < LEAGUE_SETTINGS.rosterPositions.leftWings) {
                needs.push(`${LEAGUE_SETTINGS.rosterPositions.leftWings - currentOwnerBalance.LW} LW`);
            }
            if (currentOwnerBalance.RW < LEAGUE_SETTINGS.rosterPositions.rightWings) {
                needs.push(`${LEAGUE_SETTINGS.rosterPositions.rightWings - currentOwnerBalance.RW} RW`);
            }
            if (currentOwnerBalance.D < LEAGUE_SETTINGS.rosterPositions.defensemen) {
                needs.push(`${LEAGUE_SETTINGS.rosterPositions.defensemen - currentOwnerBalance.D} Defense`);
            }
            if (currentOwnerBalance.G < LEAGUE_SETTINGS.rosterPositions.goalies) {
                needs.push(`${LEAGUE_SETTINGS.rosterPositions.goalies - currentOwnerBalance.G} Goalies`);
            }
            
            if (needs.length > 0) {
                prompts.push({
                    icon: '📊',
                    title: 'Position Needs',
                    description: needs.slice(0, 2).join(', ') + (needs.length > 2 ? '...' : ''),
                    count: needs.length,
                    action: () => switchMainTab('position-analysis')
                });
            }
        }
        
        // 3. Elite Players Still Available
        const eliteAvailable = availablePlayers.filter(p => p.rank <= 20);
        if (eliteAvailable.length > 0) {
            prompts.push({
                icon: '⭐',
                title: 'Elite Available',
                description: `${eliteAvailable.length} top-20 players left`,
                count: eliteAvailable.length,
                action: () => {
                    // Filter Best Available to show only elite players
                    switchMainTab('best-available');
                }
            });
        }
        
        // 4. Goalie Situation
        const availableGoalies = availablePlayers.filter(p => p.pos.includes('G'));
        const goalieNeeds = owners.filter(owner => {
            const balance = balances[owner];
            return balance && balance.G < LEAGUE_SETTINGS.rosterPositions.goalies;
        }).length;
        
        if (availableGoalies.length > 0 && goalieNeeds > 0) {
            prompts.push({
                icon: '🥅',
                title: 'Goalie Run Alert',
                description: `${availableGoalies.length} goalies left, ${goalieNeeds} teams need them`,
                count: availableGoalies.length,
                action: () => {
                    // Show goalies in Best Available
                    switchMainTab('best-available');
                }
            });
        }
        
        // 5. Team-Specific Suggestions
        const teamCounts = {};
        availablePlayers.forEach(player => {
            teamCounts[player.team] = (teamCounts[player.team] || 0) + 1;
        });
        
        const topTeams = Object.entries(teamCounts)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 3);
            
        if (topTeams.length > 0) {
            const [team, count] = topTeams[0];
            prompts.push({
                icon: '🏒',
                title: `${team} Players`,
                description: `${count} players available from ${team}`,
                count: count,
                action: () => {
                    // Could implement team-specific filtering
                    switchMainTab('best-available');
                }
            });
        }
        
        // 6. Draft Trends
        const recentPicks = getRecentPicks(5);
        if (recentPicks.length >= 3) {
            const positionTrend = analyzeRecentTrend(recentPicks);
            if (positionTrend) {
                prompts.push({
                    icon: '📈',
                    title: 'Draft Trend',
                    description: `Recent run on ${positionTrend}`,
                    count: recentPicks.length,
                    action: () => switchMainTab('draft-trends')
                });
            }
        }
        
        // Render prompts
        container.innerHTML = '';
        prompts.forEach(prompt => {
            const promptEl = document.createElement('div');
            promptEl.className = 'draft-prompt';
            promptEl.innerHTML = `
                <div class="draft-prompt-count">${prompt.count}</div>
                <div class="draft-prompt-header">
                    <span class="draft-prompt-icon">${prompt.icon}</span>
                    <span class="draft-prompt-title">${prompt.title}</span>
                </div>
                <div class="draft-prompt-description">${prompt.description}</div>
            `;
            promptEl.addEventListener('click', prompt.action);
            container.appendChild(promptEl);
        });
    }
    
    function getRecentPicks(count) {
        const picks = [];
        document.querySelectorAll('#tableBody .player-input').forEach(input => {
            if (input.value.trim()) {
                const player = findPlayerByName(input.value);
                if (player) {
                    const row = input.closest('tr');
                    const round = parseInt(row.dataset.round);
                    const colIndex = input.closest('td').cellIndex - 1;
                    const pickNumber = ((round - 1) * owners.length) + (colIndex + 1);
                    picks.push({ player, pickNumber });
                }
            }
        });
        
        return picks
            .sort((a, b) => b.pickNumber - a.pickNumber)
            .slice(0, count);
    }
    
    function analyzeRecentTrend(picks) {
        if (picks.length < 3) return null;
        
        const positions = picks.map(p => getPlayerPrimaryPosition(p.player));
        const positionCounts = {};
        positions.forEach(pos => {
            positionCounts[pos] = (positionCounts[pos] || 0) + 1;
        });
        
        const mostCommon = Object.entries(positionCounts)
            .sort(([,a], [,b]) => b - a)[0];
            
        if (mostCommon && mostCommon[1] >= 2) {
            const posNames = { C: 'Centers', LW: 'Left Wings', RW: 'Right Wings', D: 'Defensemen', G: 'Goalies' };
            return posNames[mostCommon[0]];
        }
        
        return null;
    }

    function updatePlayerDropdown() {
        const availablePlayers = playerRankings.filter(p => !selectedPlayers.has(p.name));
        
        // Update dropdown if it's open
        if (activeDropdown) {
            const playersToShow = availablePlayers.slice(0, 50);
            activeDropdown.innerHTML = '';
            
            playersToShow.forEach(player => {
                const option = document.createElement('div');
                option.className = 'player-option';
                
                const pos = getPlayerPrimaryPosition(player);
                option.innerHTML = `
                    <span class="player-rank">#${player.rank}</span>
                    <span>${player.name}</span>
                    <span class="player-team">${player.team}</span>
                    <span class="player-pos ${positionTextColors[pos]}">${player.pos}</span>
                `;
                
                option.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    const input = document.activeElement;
                    if (input && input.matches('input[type="text"]')) {
                        handlePlayerSelection(input, player);
                    }
                });
                
                activeDropdown.appendChild(option);
            });
            
            activeDropdown.style.display = playersToShow.length > 0 ? 'block' : 'none';
        }
    }

    // Update the best available panel
    function updateBestAvailablePanelWithFilters() {
        try {
            // Update sidebar panel (if it exists)
            const sidebarPanel = document.getElementById('bestAvailableList');
            if (sidebarPanel) {
                const availablePlayers = playerRankings.filter(p => !selectedPlayers.has(p.name));
                const playersToShow = availablePlayers.slice(0, 20);

                sidebarPanel.innerHTML = '';

                if (playersToShow.length === 0) {
                    sidebarPanel.innerHTML = '<p class="text-gray-400 text-sm">All players selected!</p>';
                    return;
                }

                playersToShow.forEach(player => {
                    const div = document.createElement('div');
                    div.className = 'best-available-player';
                    const pos = getPlayerPrimaryPosition(player);
                    div.innerHTML = `
                        <span class="player-rank">#${player.rank}</span>
                        <span>${player.name}</span>
                        <span class="player-team">${player.team}</span>
                        <span class="player-pos ${positionTextColors[pos]}">${player.pos}</span>
                    `;
                    sidebarPanel.appendChild(div);
                });
            }
        } catch (error) {
            console.error('Error in updateBestAvailablePanelWithFilters:', error);
        }
    }


    // --- TEAM ROSTER VIEW ---
    function showTeamRosters() {
        const panel = document.getElementById('bestAvailableList');
        if (!panel) return;
        
        const balances = analyzePositionBalance();
        
        panel.innerHTML = '';
        
        owners.forEach(owner => {
            const balance = balances[owner];
            const ownerDiv = document.createElement('div');
            ownerDiv.className = 'mb-4';
            
            ownerDiv.innerHTML = `
                <div class="team-name">${owner}</div>
                <div class="text-xs text-gray-400 mb-2">
                    C: ${balance.C} | LW: ${balance.LW} | RW: ${balance.RW} | D: ${balance.D} | G: ${balance.G} | Total: ${balance.total}
                </div>
            `;
            
            // Get players for this owner
            const ownerPlayers = [];
            document.querySelectorAll('#tableBody tr').forEach(row => {
                const round = parseInt(row.dataset.round);
                row.querySelectorAll('td:not(:first-child)').forEach((cell, colIndex) => {
                    if (owners[colIndex] === owner) {
                        const input = cell.querySelector('input[type="text"]');
                        if (input && input.value.trim()) {
                            const player = findPlayerByName(input.value);
                            if (player) {
                                ownerPlayers.push({ player, round });
                            }
                        }
                    }
                });
            });
            
            // Sort by round
            ownerPlayers.sort((a, b) => a.round - b.round);
            
            ownerPlayers.forEach(({ player, round }) => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'team-roster-item';
                const pos = getPlayerPrimaryPosition(player);
                
                playerDiv.innerHTML = `
                    <span class="player-rank">R${round}</span>
                    <span>${player.name}</span>
                    <span class="player-team">${player.team}</span>
                    <span class="player-pos ${positionTextColors[pos]}">${player.pos}</span>
                `;
                
                ownerDiv.appendChild(playerDiv);
            });
            
            panel.appendChild(ownerDiv);
        });
    }

    // --- TAB FUNCTIONALITY ---
    function switchMainTab(tabName) {
        currentMainTab = tabName;
        
        // Update main tab buttons
        document.querySelectorAll('.main-tab-button').forEach(btn => {
            btn.classList.remove('active');
        });
        document.querySelector(`[data-main-tab="${tabName}"]`).classList.add('active');
        
        // Update main tab content
        document.querySelectorAll('.main-tab-content').forEach(content => {
            content.classList.add('hidden');
        });
        document.getElementById(`main-tab-${tabName}`).classList.remove('hidden');
        
        // Update content based on tab
        updateCurrentTabContent();
    }
    
    function switchTab(tabName) {
        currentTab = tabName;
        
        // Update tab buttons
        document.querySelectorAll('.tab-button').forEach(btn => {
            btn.classList.remove('active');
        });
        const tabBtn = document.querySelector(`[data-tab="${tabName}"]`);
        if (tabBtn) tabBtn.classList.add('active');
        
        // Update tab content
        document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.add('hidden');
        });
        const tabContent = document.getElementById(`tab-${tabName}`);
        if (tabContent) tabContent.classList.remove('hidden');
        
        // Update content based on tab
        updateCurrentTabContent();
    }
    
    function updateCurrentTabContent() {
        console.log('=== UPDATE CURRENT TAB CONTENT DEBUG ===');
        console.log('Current tab:', currentTab);
        console.log('Current main tab:', currentMainTab);
        
        // Update sidebar content (if it exists) - using currentTab for legacy sidebar
        switch (currentTab) {
            case 'best-available':
                console.log('Updating best available panel...');
                updateBestAvailablePanelWithFilters();
                break;
            case 'team-rosters':
                console.log('Updating team rosters...');
            showTeamRosters();
                break;
            case 'position-analysis':
                console.log('Updating position analysis...');
                showPositionAnalysis();
                break;
            case 'draft-trends':
                console.log('Updating draft trends...');
                showDraftTrends();
                break;
        }
        
        console.log('=== END UPDATE CURRENT TAB CONTENT DEBUG ===');
        
        // Update full-screen content
        updateFullScreenContent();
    }
    
    function updateFullScreenContent() {
        switch (currentMainTab) {
            case 'best-available':
                updateFullScreenBestAvailable();
                break;
            case 'position-analysis':
                updateFullScreenPositionAnalysis();
                break;
            case 'team-rosters':
                updateFullScreenTeamRosters();
                break;
            case 'draft-trends':
                updateFullScreenDraftTrends();
                break;
        }
    }
    
    function updateFullScreenBestAvailable() {
        try {
            const overallContainer = document.getElementById('overallPlayers');
            const centerContainer = document.getElementById('centerPlayers');
            const leftWingContainer = document.getElementById('leftWingPlayers');
            const rightWingContainer = document.getElementById('rightWingPlayers');
            const defenseContainer = document.getElementById('defensePlayers');
            const goalieContainer = document.getElementById('goaliePlayers');
            
            if (!overallContainer || !centerContainer || !leftWingContainer || !rightWingContainer || !defenseContainer || !goalieContainer) {
                console.warn('Missing containers for full-screen best available update');
                return;
            }
        
        // Add current draft round section to the main Best Available tab
        const mainTabContainer = document.querySelector('#main-tab-best-available .bg-gray-800');
        if (mainTabContainer) {
            // Check if current round section already exists
            let currentRoundSection = mainTabContainer.querySelector('.current-draft-round-section');
            if (!currentRoundSection) {
                currentRoundSection = document.createElement('div');
                currentRoundSection.className = 'current-draft-round-section mb-6';
                mainTabContainer.insertBefore(currentRoundSection, mainTabContainer.firstChild);
            }
            
            // Get current pick number and round
            const currentPick = getCurrentPickNumber();
            const currentRound = Math.ceil(currentPick / owners.length);
            const currentOwner = getCurrentOwner();
            
            currentRoundSection.innerHTML = `
                <div class="bg-gray-700 rounded-lg p-4">
                    <div class="flex justify-between items-center mb-4">
                        <div class="flex items-center space-x-4">
                            <span class="text-xl font-bold text-white">Round ${currentRound}</span>
                            <span class="text-sm text-gray-400">Pick #${currentPick}</span>
                            <span class="text-sm text-yellow-400 font-semibold">${currentOwner} is on the clock</span>
                        </div>
                        <button onclick="switchMainTab('draft-board')" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                            <i class="fas fa-table mr-2"></i>Go to Draft Board
                        </button>
                    </div>
                    <div class="grid grid-cols-10 gap-2">
                        ${Array.from({length: owners.length}, (_, i) => {
                            const pickNum = (currentRound - 1) * owners.length + i + 1;
                            const owner = owners[i];
                            const isCurrentPick = pickNum === currentPick;
                            
                            // Find the player for this pick
                            let playerName = '';
                            let playerTeam = '';
                            let playerPos = '';
                            
                            document.querySelectorAll('#tableBody tr').forEach(row => {
                                const round = parseInt(row.dataset.round);
                                if (round === currentRound) {
                                    const cell = row.querySelector(`td:nth-child(${i + 2})`);
                                    if (cell) {
                                        const input = cell.querySelector('input[type="text"]');
                                        if (input && input.value.trim()) {
                                            const player = findPlayerByName(input.value);
                                            if (player) {
                                                playerName = player.name;
                                                playerTeam = player.team;
                                                playerPos = player.pos;
                                            }
                                        }
                                    }
                                }
                            });
                            
                            return `
                                <div class="p-3 rounded-lg text-center ${isCurrentPick ? 'bg-yellow-600 border-2 border-yellow-400' : 'bg-gray-600'}">
                                    <div class="text-xs text-gray-300 mb-1">${owner}</div>
                                    <div class="text-xs font-bold ${isCurrentPick ? 'text-yellow-200' : 'text-white'}">#${pickNum}</div>
                                    ${playerName ? `
                                        <div class="text-xs text-white mt-1">${playerName}</div>
                                        <div class="text-xs text-gray-400">${playerTeam} • ${playerPos}</div>
                                    ` : `
                                        <div class="text-xs text-gray-500 mt-1">${isCurrentPick ? 'Your Pick!' : 'Empty'}</div>
                                    `}
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            `;
        }
        
        const availablePlayers = playerRankings.filter(p => !selectedPlayers.has(p.name));
        
        // Clear all containers
        overallContainer.innerHTML = '';
        centerContainer.innerHTML = '';
        leftWingContainer.innerHTML = '';
        rightWingContainer.innerHTML = '';
        defenseContainer.innerHTML = '';
        goalieContainer.innerHTML = '';
        
        if (availablePlayers.length === 0) {
            const message = 'All players selected!';
            
            overallContainer.innerHTML = `<p class="text-gray-400 text-sm">${message}</p>`;
            centerContainer.innerHTML = `<p class="text-gray-400 text-sm">${message}</p>`;
            leftWingContainer.innerHTML = `<p class="text-gray-400 text-sm">${message}</p>`;
            rightWingContainer.innerHTML = `<p class="text-gray-400 text-sm">${message}</p>`;
            defenseContainer.innerHTML = `<p class="text-gray-400 text-sm">${message}</p>`;
            goalieContainer.innerHTML = `<p class="text-gray-400 text-sm">${message}</p>`;
            return;
        }
        
        // Separate players by position
        const overallPlayers = availablePlayers.slice(0, 25); // Top 25 overall
        const centerPlayers = availablePlayers.filter(p => p.pos.includes('C')).slice(0, 25);
        const leftWingPlayers = availablePlayers.filter(p => p.pos.includes('LW')).slice(0, 25);
        const rightWingPlayers = availablePlayers.filter(p => p.pos.includes('RW')).slice(0, 25);
        const defensePlayers = availablePlayers.filter(p => p.pos.includes('D')).slice(0, 25);
        const goaliePlayers = availablePlayers.filter(p => p.pos.includes('G')).slice(0, 25);
        
        // Populate Overall column
        overallPlayers.forEach(player => {
            const div = createPlayerCard(player);
            overallContainer.appendChild(div);
        });
        
        // Populate Centers column
        centerPlayers.forEach(player => {
            const div = createPlayerCard(player);
            centerContainer.appendChild(div);
        });
        
        // Populate Left Wings column
        leftWingPlayers.forEach(player => {
            const div = createPlayerCard(player);
            leftWingContainer.appendChild(div);
        });
        
        // Populate Right Wings column
        rightWingPlayers.forEach(player => {
            const div = createPlayerCard(player);
            rightWingContainer.appendChild(div);
        });
        
        // Populate Defense column
        defensePlayers.forEach(player => {
            const div = createPlayerCard(player);
            defenseContainer.appendChild(div);
        });
        
        // Populate Goalies column
        goaliePlayers.forEach(player => {
            const div = createPlayerCard(player);
            goalieContainer.appendChild(div);
        });
        
        } catch (error) {
            console.error('Error in updateFullScreenBestAvailable:', error);
        }
    }
    
    function createPlayerCard(player) {
        const div = document.createElement('div');
        div.className = 'bg-gray-600 rounded-lg p-3 hover:bg-gray-500 transition-colors cursor-pointer';
        const pos = getPlayerPrimaryPosition(player);
        
        div.innerHTML = `
            <div class="flex items-center justify-between mb-1">
                <span class="text-xs font-bold text-yellow-400">#${player.rank}</span>
                <span class="text-xs text-gray-300">${player.team}</span>
            </div>
            <div class="text-sm font-medium text-white mb-1">${player.name}</div>
            <div class="text-xs text-gray-400">${player.pos}</div>
        `;
        
        // Add click handler to select player
        div.addEventListener('click', () => {
            console.log('=== PLAYER CLICK DEBUG ===');
            console.log('Clicked player:', player.name, 'Rank:', player.rank);
            
            // Save state to history before making changes (for undo/redo)
            saveDraftStateToHistory();
            
            // Find the first empty input cell
            const emptyInputs = document.querySelectorAll('#tableBody input[type="text"]');
            let targetInput = null;
            
            for (let input of emptyInputs) {
                if (!input.value.trim()) {
                    targetInput = input;
                    break;
                }
            }
            
            console.log('Found empty input:', targetInput);
            
            if (targetInput) {
                const cell = targetInput.closest('td');
                const row = targetInput.closest('tr');
                const round = parseInt(row.dataset.round);
                const colIndex = cell.cellIndex - 1; // -1 for round column
                
                console.log('Target cell:', cell);
                console.log('Target row:', row);
                console.log('Round:', round);
                console.log('Column index:', colIndex);
                
                console.log('Setting player in input...');
                
                // Directly set the player without dropdown logic
                targetInput.value = player.name;
                targetInput.dataset.lastValue = player.name;
                targetInput.className = 'player-input';
                const pos = getPlayerPrimaryPosition(player);
                targetInput.classList.add(positionColors[pos]);
                
                console.log('Player set in input. Position:', pos);
                
                // Update cell styling
                if (cell) {
                    cell.classList.remove('cell-forward', 'cell-defense', 'cell-goalie');
                    if (pos === 'F') {
                        cell.classList.add('cell-forward');
                    } else if (pos === 'D') {
                        cell.classList.add('cell-defense');
                    } else if (pos === 'G') {
                        cell.classList.add('cell-goalie');
                    }
                    console.log('Cell styling updated');
                }
                
                targetInput.title = `#${player.rank} ${player.name} (${player.team} - ${player.pos})`;
                
                // Update draft state
                selectedPlayers.add(player.name);
                console.log('Added to selectedPlayers set. Total selected:', selectedPlayers.size);
                
                console.log('Calling updateAllUI...');
                updateAllUI();
                console.log('Calling saveDraftState...');
                saveDraftState();
                console.log('=== END PLAYER CLICK DEBUG ===');
        } else {
                console.error('No empty input found!');
            }
        });
        
        return div;
    }
    
    // findNextEmptyPick function removed - no longer needed
    
    function updateFullScreenPositionAnalysis() {
        const container = document.getElementById('fullScreenPositionAnalysis');
        if (!container) return;
        
        const balances = analyzePositionBalance();
        
        // Clear container
        container.innerHTML = '';
        
        // Create main grid layout: Teams on top (5x2), Players below (stacked)
        const mainGrid = document.createElement('div');
        mainGrid.className = 'space-y-8';
        
        // 1. Team Position Distribution (5x2 grid)
        const teamsSection = document.createElement('div');
        teamsSection.innerHTML = '<h4 class="text-lg font-semibold text-white mb-4">Team Position Distribution</h4>';
        
        const teamsGrid = document.createElement('div');
        teamsGrid.className = 'grid grid-cols-5 gap-4';
        
        owners.forEach(owner => {
            const balance = balances[owner];
            const total = balance.total;
            if (total > 0) {
                // Calculate progress for each position
                const cProgress = Math.min(balance.C, LEAGUE_SETTINGS.rosterPositions.centers);
                const lwProgress = Math.min(balance.LW, LEAGUE_SETTINGS.rosterPositions.leftWings);
                const rwProgress = Math.min(balance.RW, LEAGUE_SETTINGS.rosterPositions.rightWings);
                const dProgress = Math.min(balance.D, LEAGUE_SETTINGS.rosterPositions.defensemen);
                const gProgress = Math.min(balance.G, LEAGUE_SETTINGS.rosterPositions.goalies);
                
                const teamDiv = document.createElement('div');
                teamDiv.className = 'bg-gray-700 rounded-lg p-4';
                
                teamDiv.innerHTML = `
                    <div class="flex justify-between items-center mb-3">
                        <span class="font-semibold text-white text-sm">${owner}</span>
                        <span class="text-xs text-gray-400">${total} players</span>
                    </div>
                    <div class="space-y-2">
                        <div class="flex justify-between items-center">
                            <span class="text-xs text-red-300">C</span>
                            <span class="text-xs text-white">${balance.C}/${LEAGUE_SETTINGS.rosterPositions.centers}</span>
                            </div>
                        <div class="w-full bg-gray-600 rounded-full h-1">
                            <div class="bg-red-500 h-1 rounded-full transition-all duration-300" style="width: ${(cProgress / LEAGUE_SETTINGS.rosterPositions.centers) * 100}%"></div>
                        </div>
                        
                        <div class="flex justify-between items-center">
                            <span class="text-xs text-orange-300">LW</span>
                            <span class="text-xs text-white">${balance.LW}/${LEAGUE_SETTINGS.rosterPositions.leftWings}</span>
                            </div>
                        <div class="w-full bg-gray-600 rounded-full h-1">
                            <div class="bg-orange-500 h-1 rounded-full transition-all duration-300" style="width: ${(lwProgress / LEAGUE_SETTINGS.rosterPositions.leftWings) * 100}%"></div>
                        </div>
                        
                        <div class="flex justify-between items-center">
                            <span class="text-xs text-pink-300">RW</span>
                            <span class="text-xs text-white">${balance.RW}/${LEAGUE_SETTINGS.rosterPositions.rightWings}</span>
                            </div>
                        <div class="w-full bg-gray-600 rounded-full h-1">
                            <div class="bg-pink-500 h-1 rounded-full transition-all duration-300" style="width: ${(rwProgress / LEAGUE_SETTINGS.rosterPositions.rightWings) * 100}%"></div>
                        </div>
                        
                        <div class="flex justify-between items-center">
                            <span class="text-xs text-blue-300">D</span>
                            <span class="text-xs text-white">${balance.D}/${LEAGUE_SETTINGS.rosterPositions.defensemen}</span>
                            </div>
                        <div class="w-full bg-gray-600 rounded-full h-1">
                            <div class="bg-blue-500 h-1 rounded-full transition-all duration-300" style="width: ${(dProgress / LEAGUE_SETTINGS.rosterPositions.defensemen) * 100}%"></div>
                        </div>
                        
                        <div class="flex justify-between items-center">
                            <span class="text-xs text-yellow-300">G</span>
                            <span class="text-xs text-white">${balance.G}/${LEAGUE_SETTINGS.rosterPositions.goalies}</span>
                            </div>
                        <div class="w-full bg-gray-600 rounded-full h-1">
                            <div class="bg-yellow-500 h-1 rounded-full transition-all duration-300" style="width: ${(gProgress / LEAGUE_SETTINGS.rosterPositions.goalies) * 100}%"></div>
                        </div>
                    </div>
                `;
                teamsGrid.appendChild(teamDiv);
            }
        });
        
        teamsSection.appendChild(teamsGrid);
        mainGrid.appendChild(teamsSection);
        
        // 2. Position Players Analysis (stacked vertically)
        const playersSection = document.createElement('div');
        playersSection.innerHTML = '<h4 class="text-lg font-semibold text-white mb-4">Position Players Analysis</h4>';
        
        const playersContainer = document.createElement('div');
        playersContainer.className = 'space-y-6';
        
        // Get all drafted players grouped by position
        const positionPlayers = { C: [], LW: [], RW: [], D: [], G: [] };
        
        document.querySelectorAll('#tableBody tr').forEach(row => {
            const round = parseInt(row.dataset.round);
            row.querySelectorAll('td:not(:first-child)').forEach((cell, colIndex) => {
                const input = cell.querySelector('input[type="text"]');
                if (input && input.value.trim()) {
                    const player = findPlayerByName(input.value);
                    if (player) {
                        const pos = getPlayerPrimaryPosition(player);
                        if (positionPlayers[pos]) {
                            positionPlayers[pos].push({
                                player: player,
                                owner: owners[colIndex],
                                round: round
                            });
                        }
                    }
                }
            });
        });
        
        // Create stacked position sections
        Object.entries(positionPlayers).forEach(([position, players]) => {
            if (players.length > 0) {
                const positionDiv = document.createElement('div');
                positionDiv.className = 'bg-gray-700 rounded-lg p-4';
                
                const positionNames = { C: 'Centers', LW: 'Left Wings', RW: 'Right Wings', D: 'Defensemen', G: 'Goalies' };
                const positionColors = { C: 'red', LW: 'orange', RW: 'pink', D: 'blue', G: 'yellow' };
                
                positionDiv.innerHTML = `
                    <h5 class="text-md font-semibold text-${positionColors[position]}-300 mb-3">${positionNames[position]} (${players.length} drafted)</h5>
                    <div class="space-y-2">
                        ${players.sort((a, b) => a.round - b.round).map(({ player, owner, round }) => `
                            <div class="flex items-center justify-between bg-gray-600 rounded p-2">
                                <div class="flex items-center space-x-3">
                                    <span class="text-xs bg-gray-500 px-2 py-1 rounded">R${round}</span>
                                    <span class="text-white font-medium">${player.name}</span>
                                    <span class="text-gray-400 text-sm">${player.team}</span>
                                </div>
                                <span class="text-sm text-gray-300">${owner}</span>
                            </div>
                        `).join('')}
                    </div>
                `;
                playersContainer.appendChild(positionDiv);
            }
        });
        
        playersSection.appendChild(playersContainer);
        mainGrid.appendChild(playersSection);
        
        container.appendChild(mainGrid);
    }
    
    function updateFullScreenTeamRosters() {
        const container = document.getElementById('fullScreenTeamRosters');
        if (!container) return;
        
        const balances = analyzePositionBalance();
        
        container.innerHTML = '';
        
        // Create grid container with 5 columns
        const gridContainer = document.createElement('div');
        gridContainer.className = 'grid grid-cols-5 gap-4';
        
        owners.forEach(owner => {
            const balance = balances[owner];
            const ownerDiv = document.createElement('div');
            ownerDiv.className = 'bg-gray-700 rounded-lg p-4 mb-4';
            
            ownerDiv.innerHTML = `
                <div class="team-name text-lg font-semibold mb-2">${owner}</div>
                <div class="text-xs text-gray-400 mb-3">
                    C: ${balance.C} | LW: ${balance.LW} | RW: ${balance.RW} | D: ${balance.D} | G: ${balance.G} | Total: ${balance.total}
                </div>
            `;
            
            // Get players for this owner
            const ownerPlayers = [];
            document.querySelectorAll('#tableBody tr').forEach(row => {
                const round = parseInt(row.dataset.round);
                row.querySelectorAll('td:not(:first-child)').forEach((cell, colIndex) => {
                    if (owners[colIndex] === owner) {
                        const input = cell.querySelector('input[type="text"]');
                        if (input && input.value.trim()) {
                            const player = findPlayerByName(input.value);
                            if (player) {
                                ownerPlayers.push({ player, round });
                            }
                        }
                    }
                });
            });
            
            // Sort by round
            ownerPlayers.sort((a, b) => a.round - b.round);
            
            // Create players container
            const playersContainer = document.createElement('div');
            playersContainer.className = 'space-y-1';
            
            ownerPlayers.forEach(({ player, round }) => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'team-roster-item flex items-center justify-between text-sm';
                const pos = getPlayerPrimaryPosition(player);
                
                playerDiv.innerHTML = `
                    <div class="flex items-center space-x-2">
                        <span class="text-xs bg-gray-600 px-1 rounded">R${round}</span>
                        <span class="text-white">${player.name}</span>
                    </div>
                    <div class="flex items-center space-x-1">
                        <span class="text-gray-400 text-xs">${player.team}</span>
                        <span class="player-pos ${positionTextColors[pos]} text-xs">${player.pos}</span>
                    </div>
                `;
                
                playersContainer.appendChild(playerDiv);
            });
            
            ownerDiv.appendChild(playersContainer);
            gridContainer.appendChild(ownerDiv);
        });
        
        container.appendChild(gridContainer);
    }
    
    function updateFullScreenDraftTrends() {
        const container = document.getElementById('fullScreenDraftTrends');
        if (!container) return;
        
        // Get current draft state
        const currentPick = getCurrentPickNumber();
        const currentOwner = getCurrentOwner();
        const currentRound = Math.ceil(currentPick / owners.length);
        
        // Enhanced strategic analysis
        const analysis = performStrategicDraftAnalysis(currentOwner, currentPick);
        
        container.innerHTML = `
            <div class="space-y-6">
                <!-- Current Pick Context -->
                <div class="p-4 bg-gradient-to-r from-indigo-900/20 to-indigo-800/20 rounded-lg border border-indigo-700/30">
                    <h4 class="font-semibold text-white mb-3 flex items-center">
                        <i class="fas fa-crosshairs mr-2 text-indigo-400"></i>Current Pick Analysis
                    </h4>
                    <div class="grid grid-cols-3 gap-4">
                        <div class="text-center">
                            <div class="text-2xl font-bold text-indigo-300">Pick #${currentPick}</div>
                            <div class="text-sm text-gray-300">Round ${currentRound}</div>
                        </div>
                        <div class="text-center">
                            <div class="text-lg font-bold text-white">${currentOwner}</div>
                            <div class="text-sm text-gray-300">On the Clock</div>
                        </div>
                        <div class="text-center">
                            <div class="text-lg font-bold text-green-300">${analysis.availablePlayers && analysis.availablePlayers.length ? analysis.availablePlayers.length : 0}</div>
                            <div class="text-sm text-gray-300">Players Available</div>
                        </div>
                    </div>
                </div>

                <!-- Top Positional Need -->
                ${analysis.topPositionalNeed ? `
                    <div class="p-4 bg-gradient-to-r from-red-900/20 to-red-800/20 rounded-lg border border-red-700/30">
                        <h4 class="font-semibold text-white mb-3 flex items-center">
                            <i class="fas fa-bullseye mr-2 text-red-400"></i>🎯 Top Positional Need
                        </h4>
                        <div class="p-3 bg-red-800/30 rounded">
                            <div class="text-sm text-red-200 font-semibold mb-2">${analysis.topPositionalNeed && analysis.topPositionalNeed.position ? analysis.topPositionalNeed.position : 'Unknown'} Priority</div>
                            <div class="text-xs text-red-300 mb-2">${analysis.topPositionalNeed && analysis.topPositionalNeed.reasoning ? analysis.topPositionalNeed.reasoning : 'Need more draft data'}</div>
                            <div class="text-xs text-red-400">
                                ${analysis.topPositionalNeed && analysis.topPositionalNeed.topAvailable && analysis.topPositionalNeed.topAvailable.length > 0 ? `
                                    Best Available: ${analysis.topPositionalNeed.topAvailable.slice(0, 3).map(p => `${p.name} (#${p.rank})`).join(', ')}
                                ` : 'No elite options remaining'}
                            </div>
                        </div>
                    </div>
                ` : ''}

                <!-- Best Value Pick -->
                ${analysis.bestValuePick ? `
                    <div class="p-4 bg-gradient-to-r from-green-900/20 to-green-800/20 rounded-lg border border-green-700/30">
                        <h4 class="font-semibold text-white mb-3 flex items-center">
                            <i class="fas fa-gem mr-2 text-green-400"></i>💎 Best Value Pick
                        </h4>
                        <div class="p-3 bg-green-800/30 rounded">
                            <div class="text-sm text-green-200 font-semibold mb-1">${analysis.bestValuePick && analysis.bestValuePick.player && analysis.bestValuePick.player.name ? analysis.bestValuePick.player.name : 'No value pick found'}</div>
                            <div class="text-xs text-green-300 mb-2">${analysis.bestValuePick && analysis.bestValuePick.player && analysis.bestValuePick.player.rank ? `Rank #${analysis.bestValuePick.player.rank} • Pick #${currentPick} • +${analysis.bestValuePick.value || 0} value` : 'Need more draft data'}</div>
                            <div class="text-xs text-green-400">${analysis.bestValuePick && analysis.bestValuePick.reasoning ? analysis.bestValuePick.reasoning : 'Analyzing draft data...'}</div>
                        </div>
                    </div>
                ` : ''}

                <!-- Positional Run Alert -->
                ${analysis.positionalRunAlert ? `
                    <div class="p-4 bg-gradient-to-r from-purple-900/20 to-purple-800/20 rounded-lg border border-purple-700/30">
                        <h4 class="font-semibold text-white mb-3 flex items-center">
                            <i class="fas fa-bolt mr-2 text-purple-400"></i>🔥 Positional Run Alert
                        </h4>
                        <div class="p-3 bg-purple-800/30 rounded">
                            <div class="text-sm text-purple-200 font-semibold mb-1">${analysis.positionalRunAlert && analysis.positionalRunAlert.position ? analysis.positionalRunAlert.position : 'No active runs'} Run Active</div>
                            <div class="text-xs text-purple-300 mb-2">${analysis.positionalRunAlert && analysis.positionalRunAlert.description ? analysis.positionalRunAlert.description : 'Monitoring draft patterns...'}</div>
                            <div class="text-xs text-purple-400">${analysis.positionalRunAlert && analysis.positionalRunAlert.recommendation ? analysis.positionalRunAlert.recommendation : 'No recommendations yet'}</div>
                        </div>
                    </div>
                ` : ''}

                <!-- Opponent Threat Analysis -->
                ${analysis.opponentThreats && analysis.opponentThreats.length > 0 ? `
                    <div class="p-4 bg-gradient-to-r from-orange-900/20 to-orange-800/20 rounded-lg border border-orange-700/30">
                        <h4 class="font-semibold text-white mb-3 flex items-center">
                            <i class="fas fa-brain mr-2 text-orange-400"></i>🧠 Opponent Threat Analysis
                        </h4>
                        <div class="space-y-2">
                            ${analysis.opponentThreats.map(threat => `
                                <div class="p-2 bg-orange-800/30 rounded">
                                    <div class="text-sm text-orange-200 font-semibold">${threat.opponent} (Pick #${threat.nextPick})</div>
                                    <div class="text-xs text-orange-300">${threat.threat}</div>
                                    <div class="text-xs text-orange-400">${threat.recommendation}</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                ` : ''}

                <!-- Upcoming Pick Analysis -->
                ${analysis.upcomingPickAnalysis ? `
                    <div class="p-4 bg-gradient-to-r from-teal-900/20 to-teal-800/20 rounded-lg border border-teal-700/30">
                        <h4 class="font-semibold text-white mb-3 flex items-center">
                            <i class="fas fa-crystal-ball mr-2 text-teal-400"></i>🔮 Upcoming Pick Analysis
                        </h4>
                        <div class="p-3 bg-teal-800/30 rounded">
                            <div class="text-sm text-teal-200 font-semibold mb-2">Next 10 Picks Prediction</div>
                            <div class="text-xs text-teal-300 mb-2">${analysis.upcomingPickAnalysis && analysis.upcomingPickAnalysis.summary ? analysis.upcomingPickAnalysis.summary : 'Analyzing upcoming picks...'}</div>
                            <div class="text-xs text-teal-400">
                                ${analysis.upcomingPickAnalysis && analysis.upcomingPickAnalysis.targetedPlayers && analysis.upcomingPickAnalysis.targetedPlayers.length > 0 ? `
                                    Likely Targets: ${analysis.upcomingPickAnalysis.targetedPlayers.join(', ')}
                                ` : 'No clear targets identified'}
                            </div>
                        </div>
                    </div>
                ` : ''}

                <!-- Market Inefficiency Analysis -->
                ${analysis.marketInefficiencies && analysis.marketInefficiencies.length > 0 ? `
                    <div class="p-4 bg-gradient-to-r from-emerald-900/20 to-emerald-800/20 rounded-lg border border-emerald-700/30">
                        <h4 class="font-semibold text-white mb-3 flex items-center">
                            <i class="fas fa-chart-line mr-2 text-emerald-400"></i>📈 Market Inefficiency Analysis
                        </h4>
                        <div class="space-y-2">
                            ${analysis.marketInefficiencies.map(inefficiency => `
                                <div class="p-2 bg-emerald-800/30 rounded">
                                    <div class="text-sm text-emerald-200 font-semibold">${inefficiency.position}</div>
                                    <div class="text-xs text-emerald-300">${inefficiency.description}</div>
                                    <div class="text-xs text-emerald-400">${inefficiency.opportunity}</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                ` : ''}

                <!-- Team Strategy Profiles -->
                <div class="p-4 bg-gradient-to-r from-violet-900/20 to-violet-800/20 rounded-lg border border-violet-700/30">
                    <h4 class="font-semibold text-white mb-3 flex items-center">
                        <i class="fas fa-user-chart mr-2 text-violet-400"></i>🎭 Team Strategy Profiles
                    </h4>
                    <div class="space-y-2">
                        ${analysis.teamStrategyProfiles && analysis.teamStrategyProfiles.length > 0 ? analysis.teamStrategyProfiles.map(profile => `
                            <div class="p-2 bg-violet-800/30 rounded">
                                <div class="flex justify-between items-start mb-1">
                                    <span class="text-sm text-violet-200 font-semibold">${profile.owner}</span>
                                    <span class="text-xs px-2 py-1 rounded ${profile.strategy === 'Youth Movement' ? 'bg-green-600/30 text-green-300' : profile.strategy === 'Stars & Scrubs' ? 'bg-blue-600/30 text-blue-300' : profile.strategy === 'Balanced' ? 'bg-gray-600/30 text-gray-300' : 'bg-purple-600/30 text-purple-300'}">${profile.strategy}</span>
                                </div>
                                <div class="text-xs text-violet-300 mb-1">${profile.evidence}</div>
                                <div class="text-xs text-violet-400">${profile.prediction}</div>
                            </div>
                        `).join('') : '<div class="text-xs text-violet-300">Need more draft data to analyze team strategies</div>'}
                    </div>
                </div>

                <!-- Team Strategy Intelligence -->
                <div class="p-4 bg-gradient-to-r from-blue-900/20 to-blue-800/20 rounded-lg border border-blue-700/30">
                    <h4 class="font-semibold text-white mb-3 flex items-center">
                        <i class="fas fa-brain mr-2 text-blue-400"></i>Team Strategy Intelligence
                    </h4>
                    <div class="space-y-2">
                        ${analysis.teamStrategies && analysis.teamStrategies.length > 0 ? analysis.teamStrategies.map(strategy => `
                            <div class="flex justify-between items-center p-2 bg-gray-700/50 rounded">
                                <div>
                                    <span class="text-white font-medium">${strategy.owner}</span>
                                    <span class="text-gray-400 text-sm ml-2">(${strategy.picks} picks)</span>
                                </div>
                                <div class="text-right">
                                    <div class="text-sm text-gray-300">${strategy.strategy}</div>
                                    <div class="text-xs text-blue-300">${strategy.prediction}</div>
                                </div>
                            </div>
                        `).join('') : '<div class="text-xs text-gray-300">Need more draft data to analyze team strategies</div>'}
                    </div>
                </div>

                <!-- Value Pick Analysis -->
                <div class="p-4 bg-gradient-to-r from-green-900/20 to-green-800/20 rounded-lg border border-green-700/30">
                    <h4 class="font-semibold text-white mb-3 flex items-center">
                        <i class="fas fa-trophy mr-2 text-green-400"></i>Value Pick Analysis
                    </h4>
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <div class="text-lg font-bold text-green-300">${analysis.valuePicks && analysis.valuePicks.steals ? analysis.valuePicks.steals.length : 0}</div>
                            <div class="text-sm text-gray-300">Steals Found</div>
                        </div>
                        <div>
                            <div class="text-lg font-bold text-red-300">${analysis.valuePicks && analysis.valuePicks.reaches ? analysis.valuePicks.reaches.length : 0}</div>
                            <div class="text-sm text-gray-300">Reaches Identified</div>
                        </div>
                    </div>
                    ${analysis.valuePicks && analysis.valuePicks.steals && analysis.valuePicks.steals.length > 0 ? `
                        <div class="mt-3">
                            <div class="text-sm text-green-200 font-semibold mb-1">🎯 Recent Steals:</div>
                            ${analysis.valuePicks.steals.slice(0, 3).map(steal => `
                                <div class="text-xs text-green-300">• ${steal.player} (Rank #${steal.rank}, Picked #${steal.pick})</div>
                            `).join('')}
                        </div>
                    ` : ''}
                </div>

                <!-- Positional Run Detection -->
                ${analysis.positionalRuns && analysis.positionalRuns.length > 0 ? `
                    <div class="p-4 bg-gradient-to-r from-purple-900/20 to-purple-800/20 rounded-lg border border-purple-700/30">
                        <h4 class="font-semibold text-white mb-3 flex items-center">
                            <i class="fas fa-bolt mr-2 text-purple-400"></i>Positional Run Detection
                        </h4>
                        ${analysis.positionalRuns.map(run => `
                            <div class="p-2 bg-purple-800/30 rounded mb-2">
                                <div class="text-sm text-purple-200 font-semibold">${run.position} Run Active</div>
                                <div class="text-xs text-purple-300">${run.count} picks in last ${run.rounds} rounds</div>
                                <div class="text-xs text-purple-400 mt-1">💡 ${run.recommendation}</div>
                            </div>
                        `).join('')}
                    </div>
                ` : ''}

                <!-- Keeper League Insights -->
                <div class="p-4 bg-gradient-to-r from-yellow-900/20 to-yellow-800/20 rounded-lg border border-yellow-700/30">
                    <h4 class="font-semibold text-white mb-3 flex items-center">
                        <i class="fas fa-crown mr-2 text-yellow-400"></i>Keeper League Insights
                    </h4>
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <div class="text-lg font-bold text-yellow-300">${analysis.keeperInsights && analysis.keeperInsights.youngPlayers ? analysis.keeperInsights.youngPlayers : 0}</div>
                            <div class="text-sm text-gray-300">Under 25 Drafted</div>
                        </div>
                        <div>
                            <div class="text-lg font-bold text-orange-300">${analysis.keeperInsights && analysis.keeperInsights.agingStars ? analysis.keeperInsights.agingStars : 0}</div>
                            <div class="text-sm text-gray-300">Over 30 Drafted</div>
                        </div>
                    </div>
                    <div class="mt-3 p-2 bg-yellow-800/30 rounded">
                        <div class="text-sm text-yellow-200 font-semibold mb-1">📈 Keeper Strategy:</div>
                        <div class="text-xs text-yellow-300">${analysis.keeperInsights && analysis.keeperInsights.strategy ? analysis.keeperInsights.strategy : 'Need more draft data to analyze keeper strategy'}</div>
                    </div>
                </div>

                <!-- Actionable Recommendations -->
                <div class="p-4 bg-gradient-to-r from-indigo-900/20 to-indigo-800/20 rounded-lg border border-indigo-700/30">
                    <h4 class="font-semibold text-white mb-3 flex items-center">
                        <i class="fas fa-lightbulb mr-2 text-indigo-400"></i>Your Next Move
                    </h4>
                    <div class="space-y-2">
                        ${analysis.recommendations && analysis.recommendations.length > 0 ? analysis.recommendations.map(rec => `
                            <div class="p-3 bg-indigo-800/30 rounded border border-indigo-600/50">
                                <div class="text-sm text-indigo-200 font-semibold">${rec.priority}</div>
                                <div class="text-xs text-indigo-300 mt-1">${rec.action}</div>
                                <div class="text-xs text-indigo-400 mt-1">${rec.reasoning}</div>
                            </div>
                        `).join('') : '<div class="text-xs text-indigo-300">Need more draft data to generate recommendations</div>'}
                    </div>
                </div>

                <!-- Draft Momentum Analysis -->
                <div class="p-4 bg-gradient-to-r from-cyan-900/20 to-cyan-800/20 rounded-lg border border-cyan-700/30">
                    <h4 class="font-semibold text-white mb-3 flex items-center">
                        <i class="fas fa-chart-line mr-2 text-cyan-400"></i>Draft Momentum
                    </h4>
                    <div class="p-3 bg-cyan-800/30 rounded">
                        <div class="text-sm text-cyan-200 font-semibold mb-1">${analysis.momentumAnalysis && analysis.momentumAnalysis.trend ? analysis.momentumAnalysis.trend : 'Analyzing momentum...'}</div>
                        <div class="text-xs text-cyan-300">${analysis.momentumAnalysis && analysis.momentumAnalysis.prediction ? analysis.momentumAnalysis.prediction : 'Need more draft data'}</div>
                        ${analysis.momentumAnalysis && analysis.momentumAnalysis.shifts && analysis.momentumAnalysis.shifts.length > 0 ? `
                            <div class="mt-2">
                                <div class="text-xs text-cyan-400 font-semibold">Momentum Shifts:</div>
                                ${analysis.momentumAnalysis.shifts.map(shift => `
                                    <div class="text-xs text-cyan-300">• ${shift.position} ${shift.direction} (${shift.change > 0 ? '+' : ''}${shift.change})</div>
                                `).join('')}
                            </div>
                        ` : ''}
                    </div>
                </div>
                
                <!-- League Meta Analysis -->
                <div class="p-4 bg-gradient-to-r from-pink-900/20 to-pink-800/20 rounded-lg border border-pink-700/30">
                    <h4 class="font-semibold text-white mb-3 flex items-center">
                        <i class="fas fa-globe mr-2 text-pink-400"></i>League Meta
                    </h4>
                    <div class="space-y-3">
                        <div class="p-2 bg-pink-800/30 rounded">
                            <div class="text-sm text-pink-200 font-semibold">${analysis.metaAnalysis && analysis.metaAnalysis.description ? analysis.metaAnalysis.description : 'Analyzing league patterns...'}</div>
                            <div class="text-xs text-pink-300">${analysis.metaAnalysis && analysis.metaAnalysis.positionMeta ? analysis.metaAnalysis.positionMeta : 'Need more draft data'}</div>
                    </div>
                        
                        <!-- Position Distribution -->
                        <div class="p-2 bg-pink-800/20 rounded">
                            <div class="text-xs text-pink-400 font-semibold mb-2">Position Distribution vs Expected:</div>
                            <div class="grid grid-cols-5 gap-1 text-xs">
                                <div class="text-center">
                                    <div class="text-red-300 font-semibold">${analysis.metaAnalysis.distribution.C.toFixed(1)}%</div>
                                    <div class="text-red-400">C</div>
                                    <div class="text-gray-500">(16%)</div>
                                </div>
                                <div class="text-center">
                                    <div class="text-orange-300 font-semibold">${analysis.metaAnalysis.distribution.LW.toFixed(1)}%</div>
                                    <div class="text-orange-400">LW</div>
                                    <div class="text-gray-500">(16%)</div>
                                </div>
                                <div class="text-center">
                                    <div class="text-pink-300 font-semibold">${analysis.metaAnalysis.distribution.RW.toFixed(1)}%</div>
                                    <div class="text-pink-400">RW</div>
                                    <div class="text-gray-500">(16%)</div>
                                </div>
                                <div class="text-center">
                                    <div class="text-blue-300 font-semibold">${analysis.metaAnalysis.distribution.D.toFixed(1)}%</div>
                                    <div class="text-blue-400">D</div>
                                    <div class="text-gray-500">(24%)</div>
                                </div>
                                <div class="text-center">
                                    <div class="text-yellow-300 font-semibold">${analysis.metaAnalysis.distribution.G.toFixed(1)}%</div>
                                    <div class="text-yellow-400">G</div>
                                    <div class="text-gray-500">(8%)</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Drafting Behavior -->
                        <div class="grid grid-cols-3 gap-2 text-xs">
                            <div class="text-center p-2 bg-pink-800/20 rounded">
                                <div class="text-pink-300 font-semibold">${analysis.metaAnalysis.aggressiveTeams}</div>
                                <div class="text-pink-400">Aggressive</div>
                            </div>
                            <div class="text-center p-2 bg-pink-800/20 rounded">
                                <div class="text-pink-300 font-semibold">${analysis.metaAnalysis.conservativeTeams}</div>
                                <div class="text-pink-400">Conservative</div>
                            </div>
                            <div class="text-center p-2 bg-pink-800/20 rounded">
                                <div class="text-pink-300 font-semibold">${10 - analysis.metaAnalysis.aggressiveTeams - analysis.metaAnalysis.conservativeTeams}</div>
                                <div class="text-pink-400">Balanced</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Team Activity (Enhanced) -->
                <div class="p-4 bg-gray-700 rounded-lg">
                    <h4 class="font-semibold text-white mb-3">Team Activity & Predictions</h4>
                    <div class="space-y-2">
                        ${analysis.teamTrends && Object.keys(analysis.teamTrends).length > 0 ? Object.entries(analysis.teamTrends).map(([owner, data]) => `
                            <div class="p-2 bg-gray-600/50 rounded">
                                <div class="flex justify-between items-center mb-1">
                                    <span class="text-gray-300 font-medium">${owner}</span>
                                    <div class="flex items-center space-x-2">
                                        <span class="text-white">${data.picks} picks</span>
                                        <span class="text-xs px-2 py-1 rounded ${data.status === 'aggressive' ? 'bg-red-600/30 text-red-300' : data.status === 'conservative' ? 'bg-blue-600/30 text-blue-300' : 'bg-gray-600/30 text-gray-300'}">${data.status}</span>
                                    </div>
                                </div>
                                ${analysis.teamPredictions && analysis.teamPredictions[owner] && analysis.teamPredictions[owner].length > 0 ? `
                                    <div class="text-xs text-gray-400">
                                        ${analysis.teamPredictions[owner].slice(0, 2).map(pred => `
                                            <div>• ${pred.prediction} (${pred.confidence})</div>
                                        `).join('')}
                                    </div>
                                ` : ''}
                            </div>
                        `).join('') : '<div class="text-xs text-gray-300">Need more draft data to analyze team trends</div>'}
                    </div>
                </div>
            </div>
        `;
    }
    
    function getCurrentPickNumber() {
        // Find all empty input cells and determine the lowest pick number
        const emptyPicks = [];
        document.querySelectorAll('#tableBody input[type="text"]').forEach(input => {
            if (!input.value.trim()) {
                const row = input.closest('tr');
                const round = parseInt(row.dataset.round);
                const colIndex = input.closest('td').cellIndex - 1; // -1 for round column
                const pickNumber = ((round - 1) * owners.length) + (colIndex + 1);
                emptyPicks.push(pickNumber);
            }
        });
        
        // Return the lowest available pick number
        if (emptyPicks.length > 0) {
            return Math.min(...emptyPicks);
        }
        
        // If all picks are filled, return the next pick number
        const totalRounds = document.querySelectorAll('#tableBody tr').length;
        const lastRound = totalRounds;
        return (lastRound * owners.length) + 1;
    }
    
    function getCurrentOwner() {
        const currentPick = getCurrentPickNumber();
        const ownerIndex = (currentPick - 1) % owners.length;
        return owners[ownerIndex];
    }
    
    function performStrategicDraftAnalysis(currentOwner, currentPick) {
        // Get current team's roster
        const teamRoster = getTeamRoster(currentOwner);
        const availablePlayers = getAvailablePlayers();
        
        // Analyze top positional need
        const topPositionalNeed = analyzeTopPositionalNeed(teamRoster, availablePlayers);
        
        // Find best value pick
        const bestValuePick = findBestValuePick(availablePlayers, currentPick);
        
        // Check for positional runs
        const positionalRunAlert = detectPositionalRun();
        
        // Analyze opponent threats
        const opponentThreats = analyzeOpponentThreats(currentOwner, currentPick);
        
        // Analyze upcoming picks
        const upcomingPickAnalysis = analyzeUpcomingPicks(currentOwner, currentPick);
        
        // Analyze market inefficiencies
        const marketInefficiencies = analyzeMarketInefficiencies();
        
        // Generate team strategy profiles
        const teamStrategyProfiles = generateTeamStrategyProfiles();
        
        // Generate basic team strategies for the old section
        const teamStrategies = owners.map(owner => {
            const teamRoster = getTeamRoster(owner);
            const picks = teamRoster.total;
            
            let strategy = "Balanced";
            let prediction = "Will continue balanced approach";
            
            if (picks > 8) {
                strategy = "Aggressive";
                prediction = "Likely to continue aggressive drafting";
            } else if (picks < 6) {
                strategy = "Conservative";
                prediction = "Waiting for value, may pick soon";
            }
            
            return {
                owner: owner,
                picks: picks,
                strategy: strategy,
                prediction: prediction
            };
        });
        
        // Generate value picks analysis for the old section
        const valuePicks = analyzeValuePicks();
        
        // Generate positional runs for the old section
        const positionalRuns = analyzePositionalRuns();
        
        // Generate keeper insights for the old section
        const keeperInsights = analyzeKeeperInsights();
        
        // Generate recommendations for the old section
        const recommendations = generateRecommendations();
        
        // Generate momentum analysis for the old section
        const momentumAnalysis = analyzeMomentum();
        
        // Generate meta analysis for the old section
        const draftData = [];
        let pickNumber = 1;
        
        document.querySelectorAll('#tableBody tr').forEach(row => {
            const cells = row.querySelectorAll('td');
            if (cells.length > 1) {
                const player = cells[0].textContent.trim();
                if (player) {
                    draftData.push({
                        pick: pickNumber,
                        player: player,
                        position: getPlayerPrimaryPosition(player),
                        owner: null
                    });
                    pickNumber++;
                }
            }
        });
        
        const teamTrends = []; // Empty for now, could be populated later
        const metaAnalysis = analyzeLeagueMeta(draftData, teamTrends);
        
        // Generate team trends and predictions for the old section
        const teamTrendsData = generateTeamTrends();
        const teamPredictions = generateTeamPredictions(teamTrendsData, draftData);
        
        return {
            availablePlayers: availablePlayers,
            topPositionalNeed: topPositionalNeed,
            bestValuePick: bestValuePick,
            positionalRunAlert: positionalRunAlert,
            opponentThreats: opponentThreats,
            upcomingPickAnalysis: upcomingPickAnalysis,
            marketInefficiencies: marketInefficiencies,
            teamStrategyProfiles: teamStrategyProfiles,
            teamStrategies: teamStrategies,
            valuePicks: valuePicks,
            positionalRuns: positionalRuns,
            keeperInsights: keeperInsights,
            recommendations: recommendations,
            momentumAnalysis: momentumAnalysis,
            metaAnalysis: metaAnalysis,
            teamTrends: teamTrendsData,
            teamPredictions: teamPredictions
        };
    }
    
    function analyzeValuePicks() {
        const draftData = [];
        let pickNumber = 1;
        
        // Collect all picks
        document.querySelectorAll('#tableBody .player-input').forEach(input => {
            if (input.value.trim()) {
                const player = findPlayerByName(input.value);
                if (player) {
                    draftData.push({
                        player: player.name,
                        rank: player.rank,
                        pickNumber: pickNumber
                    });
                    pickNumber++;
                }
            }
        });
        
        const steals = [];
        const reaches = [];
        
        draftData.forEach(pick => {
            const valueDiff = pick.pickNumber - pick.rank;
            if (valueDiff > 10) {
                steals.push({
                    player: pick.player,
                    rank: pick.rank,
                    pick: pick.pickNumber,
                    value: valueDiff
                });
            } else if (valueDiff < -5) {
                reaches.push({
                    player: pick.player,
                    rank: pick.rank,
                    pick: pick.pickNumber,
                    reach: Math.abs(valueDiff)
                });
            }
        });
        
        // Sort steals by value
        steals.sort((a, b) => b.value - a.value);
        
        return {
            steals: steals,
            reaches: reaches
        };
    }
    
    function analyzePositionalRuns() {
        const recentPicks = getRecentPicks(8); // Last 8 picks
        if (recentPicks.length < 5) return []; // Need at least 5 picks to analyze
        
        const positionCounts = {};
        recentPicks.forEach(pick => {
            const pos = getPlayerPrimaryPosition(pick.player);
            positionCounts[pos] = (positionCounts[pos] || 0) + 1;
        });
        
        // Find positions with 3+ picks in recent picks
        const runs = Object.entries(positionCounts)
            .filter(([pos, count]) => count >= 3)
            .sort(([,a], [,b]) => b - a);
        
        if (runs.length === 0) return [];
        
        const positionNames = { C: 'Centers', LW: 'Left Wings', RW: 'Right Wings', D: 'Defensemen', G: 'Goalies' };
        
        return runs.map(([position, count]) => {
            let recommendation = "Consider joining the run or pivoting to another position";
            if (position === 'D' && count >= 4) {
                recommendation = "Defensemen run may be ending - consider forwards or wait";
            } else if (position === 'G' && count >= 2) {
                recommendation = "Goalies running hot - wait for better value";
            }
            
            return {
                position: positionNames[position],
                count: count,
                rounds: Math.ceil(count / owners.length),
                recommendation: recommendation
            };
        });
    }
    
    function analyzeKeeperInsights() {
        const draftData = [];
        let pickNumber = 1;
        
        document.querySelectorAll('#tableBody tr').forEach(row => {
            const cells = row.querySelectorAll('td');
            if (cells.length > 1) {
                const player = cells[0].textContent.trim();
                if (player) {
                    draftData.push({
                        pick: pickNumber,
                        player: player,
                        owner: null // We'll fill this in
                    });
                    pickNumber++;
                }
            }
        });
        
        // Count young players (under 25) and aging stars (over 30)
        let youngPlayers = 0;
        let agingStars = 0;
        
        draftData.forEach(pick => {
            const player = pick.player;
            // Simple age estimation based on common knowledge
            // This is a basic implementation - you might want to enhance with actual player data
            if (player.includes('Bedard') || player.includes('Fantilli') || player.includes('Celebrini') || 
                player.includes('Stützle') || player.includes('Caufield') || player.includes('Zegras')) {
                youngPlayers++;
            } else if (player.includes('Crosby') || player.includes('Ovechkin') || player.includes('Malkin') || 
                       player.includes('Bergeron') || player.includes('Pavelski') || player.includes('Kopitar')) {
                agingStars++;
            }
        });
        
        // Generate strategy recommendation
        let strategy = "Balanced approach - mix of youth and experience";
        if (youngPlayers > agingStars * 2) {
            strategy = "Youth movement - prioritize young talent for long-term success";
        } else if (agingStars > youngPlayers * 2) {
            strategy = "Win-now mode - aging stars for immediate impact";
        }
        
        return {
            youngPlayers: youngPlayers,
            agingStars: agingStars,
            strategy: strategy
        };
    }
    
    function generateRecommendations() {
        const currentPick = getCurrentPickNumber();
        const currentOwner = getCurrentOwner();
        const teamRoster = getTeamRoster(currentOwner);
        const availablePlayers = getAvailablePlayers();
        
        const recommendations = [];
        
        // Priority 1: Critical positional needs
        const criticalNeeds = [];
        Object.entries(LEAGUE_SETTINGS.rosterPositions).forEach(([pos, needed]) => {
            const current = teamRoster[pos] || 0;
            if (current < needed) {
                criticalNeeds.push({ position: pos, needed: needed - current });
            }
        });
        
        if (criticalNeeds.length > 0) {
            const topNeed = criticalNeeds.sort((a, b) => b.needed - a.needed)[0];
            recommendations.push({
                priority: "🔥 CRITICAL",
                action: `Draft a ${topNeed.position} - you need ${topNeed.needed} more`,
                reasoning: "Fill your most urgent positional need before talent drops off"
            });
        }
        
        // Priority 2: Value opportunities
        const valuePicks = availablePlayers.filter(player => {
            const rank = getPlayerRank(player);
            return rank && rank < currentPick; // Players ranked higher than current pick
        }).slice(0, 3);
        
        if (valuePicks.length > 0) {
            recommendations.push({
                priority: "💎 VALUE",
                action: `Consider ${valuePicks[0]} - ranked higher than current pick`,
                reasoning: "Get better value than your current draft position"
            });
        }
        
        // Priority 3: Positional runs
        const recentPicks = getRecentPicks(5);
        const positionCounts = {};
        recentPicks.forEach(pick => {
            const pos = getPlayerPrimaryPosition(pick.player);
            positionCounts[pos] = (positionCounts[pos] || 0) + 1;
        });
        
        const activeRun = Object.entries(positionCounts).find(([pos, count]) => count >= 3);
        if (activeRun) {
            recommendations.push({
                priority: "⚡ RUN ALERT",
                action: `${activeRun[0]} position is running hot`,
                reasoning: "Consider joining the run or pivoting to avoid getting left behind"
            });
        }
        
        return recommendations;
    }
    
    function analyzeMomentum() {
        const recentPicks = getRecentPicks(10);
        if (recentPicks.length < 5) {
            return {
                trend: "Early Draft Phase",
                prediction: "Momentum patterns will emerge as more picks are made",
                shifts: []
            };
        }
        
        // Analyze position distribution in recent picks
        const positionCounts = {};
        recentPicks.forEach(pick => {
            const pos = getPlayerPrimaryPosition(pick.player);
            positionCounts[pos] = (positionCounts[pos] || 0) + 1;
        });
        
        // Determine trend
        let trend = "Balanced Draft";
        const totalPicks = recentPicks.length;
        const maxPosition = Math.max(...Object.values(positionCounts));
        
        if (maxPosition / totalPicks > 0.4) {
            const dominantPos = Object.entries(positionCounts).find(([pos, count]) => count === maxPosition)[0];
            trend = `${dominantPos} Heavy Draft`;
        }
        
        // Generate prediction
        let prediction = "Expect continued balanced drafting";
        if (trend.includes("Heavy")) {
            prediction = "Positional run may continue or reverse soon";
        }
        
        // Generate shifts (simplified)
        const shifts = Object.entries(positionCounts)
            .filter(([pos, count]) => count >= 2)
            .map(([pos, count]) => ({
                position: pos,
                direction: count >= 3 ? "surge" : "steady",
                change: count
            }));
        
        return {
            trend: trend,
            prediction: prediction,
            shifts: shifts
        };
    }
    
    function generateTeamTrends() {
        const trends = {};
        
        owners.forEach(owner => {
            const roster = getTeamRoster(owner);
            const picks = roster.total;
            
            // Determine strategy based on picks
            let status = 'balanced';
            let strategy = 'Balanced approach';
            
            if (picks > 8) {
                status = 'aggressive';
                strategy = 'Aggressive drafting - filling roster quickly';
            } else if (picks < 5) {
                status = 'conservative';
                strategy = 'Conservative approach - waiting for value';
            }
            
            trends[owner] = {
                picks: picks,
                status: status,
                strategy: strategy,
                positions: {
                    G: roster.G,
                    D: roster.D,
                    C: roster.C,
                    LW: roster.LW,
                    RW: roster.RW
                }
            };
        });
        
        return trends;
    }
    
    
    function getPlayerRank(playerName) {
        const player = playerRankings.find(p => p.name === playerName);
        return player ? player.rank : null;
    }
    
    function getTeamRoster(owner) {
        const roster = { C: 0, LW: 0, RW: 0, D: 0, G: 0, total: 0 };
        const ownerIndex = owners.indexOf(owner);
        
        document.querySelectorAll('#tableBody tr').forEach(row => {
            const cell = row.querySelector(`td:nth-child(${ownerIndex + 2})`);
            if (cell) {
                const input = cell.querySelector('input[type="text"]');
                if (input && input.value.trim()) {
                const player = findPlayerByName(input.value);
                if (player) {
                    const pos = getPlayerPrimaryPosition(player);
                        roster[pos]++;
                        roster.total++;
                    }
                }
            }
        });
        
        return roster;
    }
    
    function getAvailablePlayers() {
        const selectedPlayers = new Set();
        document.querySelectorAll('#tableBody .player-input').forEach(input => {
            if (input.value.trim()) {
                selectedPlayers.add(input.value.trim());
            }
        });
        
        return playerRankings.filter(p => !selectedPlayers.has(p.name));
    }
    
    function analyzeTopPositionalNeed(teamRoster, availablePlayers) {
        const required = LEAGUE_SETTINGS.rosterPositions;
        const needs = [];
        
        // Calculate needs for each position
        if (teamRoster.G < required.goalies) {
            const availableGoalies = availablePlayers.filter(p => p.pos.includes('G'));
            needs.push({
                position: 'Goalie',
                need: required.goalies - teamRoster.G,
                urgency: teamRoster.G === 0 ? 'HIGH' : 'MEDIUM',
                topAvailable: availableGoalies.slice(0, 5),
                reasoning: `You have ${teamRoster.G}/${required.goalies} goalies. ${availableGoalies.length} available.`
            });
        }
        
        if (teamRoster.D < required.defensemen) {
            const availableDefensemen = availablePlayers.filter(p => p.pos.includes('D'));
            needs.push({
                position: 'Defenseman',
                need: required.defensemen - teamRoster.D,
                urgency: teamRoster.D < 2 ? 'HIGH' : 'MEDIUM',
                topAvailable: availableDefensemen.slice(0, 5),
                reasoning: `You have ${teamRoster.D}/${required.defensemen} defensemen. ${availableDefensemen.length} available.`
            });
        }
        
        if (teamRoster.C < required.centers) {
            const availableCenters = availablePlayers.filter(p => p.pos.includes('C'));
            needs.push({
                position: 'Center',
                need: required.centers - teamRoster.C,
                urgency: 'MEDIUM',
                topAvailable: availableCenters.slice(0, 5),
                reasoning: `You have ${teamRoster.C}/${required.centers} centers. ${availableCenters.length} available.`
            });
        }
        
        if (teamRoster.LW < required.leftWings) {
            const availableLW = availablePlayers.filter(p => p.pos.includes('LW'));
            needs.push({
                position: 'Left Wing',
                need: required.leftWings - teamRoster.LW,
                urgency: 'MEDIUM',
                topAvailable: availableLW.slice(0, 5),
                reasoning: `You have ${teamRoster.LW}/${required.leftWings} left wings. ${availableLW.length} available.`
            });
        }
        
        if (teamRoster.RW < required.rightWings) {
            const availableRW = availablePlayers.filter(p => p.pos.includes('RW'));
            needs.push({
                position: 'Right Wing',
                need: required.rightWings - teamRoster.RW,
                urgency: 'MEDIUM',
                topAvailable: availableRW.slice(0, 5),
                reasoning: `You have ${teamRoster.RW}/${required.rightWings} right wings. ${availableRW.length} available.`
            });
        }
        
        // Sort by urgency and need
        needs.sort((a, b) => {
            const urgencyOrder = { 'HIGH': 3, 'MEDIUM': 2, 'LOW': 1 };
            if (urgencyOrder[a.urgency] !== urgencyOrder[b.urgency]) {
                return urgencyOrder[b.urgency] - urgencyOrder[a.urgency];
            }
            return b.need - a.need;
        });
        
        return needs.length > 0 ? needs[0] : null;
    }
    
    function findBestValuePick(availablePlayers, currentPick) {
        if (availablePlayers.length === 0) return null;
        
        // Find players with significant value (rank much higher than current pick)
        const valuePicks = availablePlayers
            .filter(p => p.rank && p.rank < currentPick)
            .map(p => ({
                player: p,
                value: currentPick - p.rank,
                reasoning: `Ranked #${p.rank} but available at pick #${currentPick} - represents +${currentPick - p.rank} value`
            }))
            .sort((a, b) => b.value - a.value);
        
        return valuePicks.length > 0 ? valuePicks[0] : null;
    }
    
    function detectPositionalRun() {
        const recentPicks = getRecentPicks(8); // Last 8 picks
        if (recentPicks.length < 5) return null;
        
        const positionCounts = {};
        recentPicks.forEach(pick => {
            const pos = getPlayerPrimaryPosition(pick.player);
            positionCounts[pos] = (positionCounts[pos] || 0) + 1;
        });
        
        // Find positions with 3+ picks in recent picks
        const runs = Object.entries(positionCounts)
            .filter(([pos, count]) => count >= 3)
            .sort(([,a], [,b]) => b - a);
        
        if (runs.length === 0) return null;
        
        const [position, count] = runs[0];
        const positionNames = { C: 'Centers', LW: 'Left Wings', RW: 'Right Wings', D: 'Defensemen', G: 'Goalies' };
        
        let recommendation = "Consider joining the run or pivoting to another position";
        if (position === 'D' && count >= 4) {
            recommendation = "Defensemen run may be ending - consider forwards or wait";
        } else if (position === 'G' && count >= 2) {
            recommendation = "Goalies running hot - wait for better value";
        }
        
        return {
            position: positionNames[position],
            count: count,
            description: `${count} ${positionNames[position].toLowerCase()} in last 8 picks`,
            recommendation: recommendation
        };
    }
    
    function analyzeOpponentThreats(currentOwner, currentPick) {
        const threats = [];
        const currentOwnerIndex = owners.indexOf(currentOwner);
        
        // Analyze next few teams to pick
        for (let i = 1; i <= 3; i++) {
            const nextOwnerIndex = (currentOwnerIndex + i) % owners.length;
            const nextOwner = owners[nextOwnerIndex];
            const nextPick = currentPick + i;
            
            const nextTeamRoster = getTeamRoster(nextOwner);
            const availablePlayers = getAvailablePlayers();
            
            // Check for critical needs
            if (nextTeamRoster.G === 0) {
                const availableGoalies = availablePlayers.filter(p => p.pos.includes('G'));
                if (availableGoalies.length > 0) {
                    threats.push({
                        opponent: nextOwner,
                        nextPick: nextPick,
                        threat: `Needs a goalie badly - will likely take one of the ${availableGoalies.length} available`,
                        recommendation: "Consider taking a goalie now if you need one"
                    });
                }
            }
            
            if (nextTeamRoster.D < 2) {
                const availableDefensemen = availablePlayers.filter(p => p.pos.includes('D'));
                if (availableDefensemen.length > 0) {
                    threats.push({
                        opponent: nextOwner,
                        nextPick: nextPick,
                        threat: `Only has ${nextTeamRoster.D} defensemen - needs defensive help`,
                        recommendation: "Monitor defensemen availability"
                    });
                }
            }
        }
        
        return threats.slice(0, 2); // Limit to top 2 threats
    }
    
    function analyzeUpcomingPicks(currentOwner, currentPick) {
        const currentOwnerIndex = owners.indexOf(currentOwner);
        const upcomingPicks = [];
        const positionNeeds = {};
        
        // Analyze next 10 picks
        for (let i = 1; i <= 10; i++) {
            const nextOwnerIndex = (currentOwnerIndex + i) % owners.length;
            const nextOwner = owners[nextOwnerIndex];
            const nextPick = currentPick + i;
            
            const teamRoster = getTeamRoster(nextOwner);
            const needs = [];
            
            // Check critical needs
            if (teamRoster.G === 0) needs.push('G');
            if (teamRoster.D < 2) needs.push('D');
            if (teamRoster.C < 2) needs.push('C');
            if (teamRoster.LW < 2) needs.push('LW');
            if (teamRoster.RW < 2) needs.push('RW');
            
            upcomingPicks.push({
                owner: nextOwner,
                pick: nextPick,
                needs: needs
            });
            
            // Count position needs
            needs.forEach(pos => {
                positionNeeds[pos] = (positionNeeds[pos] || 0) + 1;
            });
        }
        
        // Find most critical position needs
        const criticalNeeds = Object.entries(positionNeeds)
            .filter(([pos, count]) => count >= 3)
            .sort(([,a], [,b]) => b - a);
        
        if (criticalNeeds.length === 0) return null;
        
        const [topPosition, count] = criticalNeeds[0];
        const positionNames = { C: 'Centers', LW: 'Left Wings', RW: 'Right Wings', D: 'Defensemen', G: 'Goalies' };
        
        // Get top available players at that position
        const availablePlayers = getAvailablePlayers();
        const targetedPlayers = availablePlayers
            .filter(p => getPlayerPrimaryPosition(p) === topPosition)
            .slice(0, 3)
            .map(p => `${p.name} (#${p.rank})`);
        
        return {
            summary: `In the next 10 picks, ${count} teams have a critical need for ${positionNames[topPosition].toLowerCase()}`,
            targetedPlayers: targetedPlayers,
            criticalPosition: topPosition,
            affectedTeams: upcomingPicks.filter(p => p.needs.includes(topPosition)).map(p => p.owner)
        };
    }
    
    function analyzeMarketInefficiencies() {
        const draftData = [];
        let totalPicks = 0;
        
        // Collect all picks
        document.querySelectorAll('#tableBody .player-input').forEach(input => {
            if (input.value.trim()) {
                const player = findPlayerByName(input.value);
                if (player) {
                    draftData.push({
                        position: getPlayerPrimaryPosition(player),
                        pickNumber: totalPicks + 1
                    });
                    totalPicks++;
                }
            }
        });
        
        if (draftData.length < 20) return []; // Need enough data
        
        const totalDrafted = draftData.length;
        const positionCounts = {};
        draftData.forEach(pick => {
            positionCounts[pick.position] = (positionCounts[pick.position] || 0) + 1;
        });
        
        // Calculate expected vs actual distribution
        const expectedDistribution = {
            C: 0.16, // 4 centers * 10 teams / 250 picks
            LW: 0.16, // 4 LW * 10 teams / 250 picks
            RW: 0.16, // 4 RW * 10 teams / 250 picks
            D: 0.24, // 6 D * 10 teams / 250 picks
            G: 0.08  // 2 G * 10 teams / 250 picks
        };
        
        const inefficiencies = [];
        
        Object.entries(positionCounts).forEach(([pos, count]) => {
            const actualPercentage = count / totalDrafted;
            const expectedPercentage = expectedDistribution[pos];
            const deviation = ((actualPercentage - expectedPercentage) / expectedPercentage) * 100;
            
            if (Math.abs(deviation) > 15) { // 15% deviation threshold
                const positionNames = { C: 'Centers', LW: 'Left Wings', RW: 'Right Wings', D: 'Defensemen', G: 'Goalies' };
                
                if (deviation > 0) {
                    inefficiencies.push({
                        position: positionNames[pos],
                        description: `Over-drafting ${positionNames[pos].toLowerCase()} (${deviation.toFixed(1)}% above expected pace)`,
                        opportunity: `Significant value available at other positions`
                    });
                } else {
                    inefficiencies.push({
                        position: positionNames[pos],
                        description: `Under-drafting ${positionNames[pos].toLowerCase()} (${Math.abs(deviation).toFixed(1)}% below expected pace)`,
                        opportunity: `Excellent value to be had at ${positionNames[pos].toLowerCase()}`
                    });
                }
            }
        });
        
        return inefficiencies.slice(0, 3); // Top 3 inefficiencies
    }
    
    function generateTeamStrategyProfiles() {
        const profiles = [];
        
        owners.forEach(owner => {
            const teamRoster = getTeamRoster(owner);
            const draftedPlayers = getDraftedPlayers(owner);
            
            if (draftedPlayers.length < 2) return; // Need at least 2 picks to analyze
            
            // Analyze strategy based on picks
            let strategy = 'Balanced';
            let evidence = '';
            let prediction = 'Will continue balanced approach';
            
            // Check for youth movement (young players)
            const youngPlayers = draftedPlayers.filter(p => p.age < 25).length;
            const totalPlayers = draftedPlayers.length;
            
            if (youngPlayers / totalPlayers > 0.7) {
                strategy = 'Youth Movement';
                evidence = `Drafted ${youngPlayers}/${totalPlayers} young players (under 25)`;
                prediction = 'Will likely target high-upside young players like Celebrini or Fantilli next';
            }
            
            // Check for stars & scrubs (high variance in rankings)
            const rankings = draftedPlayers.map(p => p.rank).sort((a, b) => a - b);
            const rankingSpread = rankings[rankings.length - 1] - rankings[0];
            
            if (rankingSpread > 50 && rankings[0] < 20) {
                strategy = 'Stars & Scrubs';
                evidence = `Drafted elite players (rank ${rankings[0]}) mixed with deep picks (rank ${rankings[rankings.length - 1]})`;
                prediction = 'Will likely target safer, lower-ranked players to fill out positional needs in mid-rounds';
            }
            
            // Check for position-heavy drafting
            const positionCounts = {};
            draftedPlayers.forEach(p => {
                const pos = getPlayerPrimaryPosition(p);
                positionCounts[pos] = (positionCounts[pos] || 0) + 1;
            });
            
            const maxPosition = Object.entries(positionCounts).reduce((a, b) => 
                positionCounts[a[0]] > positionCounts[b[0]] ? a : b
            );
            
            if (maxPosition[1] >= 2 && totalPlayers >= 3) {
                strategy = `${maxPosition[0]} Heavy`;
                evidence = `Drafted ${maxPosition[1]} ${maxPosition[0]} players`;
                prediction = `Will likely continue focusing on ${maxPosition[0]} depth`;
            }
            
            profiles.push({
                owner: owner,
                strategy: strategy,
                evidence: evidence,
                prediction: prediction
            });
        });
        
        return profiles.slice(0, 6); // Top 6 profiles
    }
    
    function getDraftedPlayers(owner) {
        const draftedPlayers = [];
        const ownerIndex = owners.indexOf(owner);
        
        document.querySelectorAll('#tableBody tr').forEach(row => {
            const cell = row.querySelector(`td:nth-child(${ownerIndex + 2})`);
            if (cell) {
                const input = cell.querySelector('input[type="text"]');
                if (input && input.value.trim()) {
                    const player = findPlayerByName(input.value);
                    if (player) {
                        draftedPlayers.push({
                            ...player,
                            age: player.age || 25 // Default age if not available
                        });
                    }
                }
            }
        });
        
        return draftedPlayers;
    }
    
    function performAdvancedDraftAnalysis() {
        // Collect all draft data
        const draftData = [];
        const teamData = {};
        const positionData = { C: 0, LW: 0, RW: 0, D: 0, G: 0 };
        const teamTrends = {};
        
        // Initialize team data
        owners.forEach(owner => {
            teamTrends[owner] = { 
                picks: 0, 
                positions: { C: 0, LW: 0, RW: 0, D: 0, G: 0 }, 
                recentPicks: [],
                status: 'balanced'
            };
            teamData[owner] = [];
        });
        
        // Collect all picks with detailed information
        document.querySelectorAll('#tableBody .player-input').forEach(input => {
            if (input.value.trim()) {
                const player = findPlayerByName(input.value);
                if (player) {
                    const row = input.closest('tr');
                    const round = parseInt(row.dataset.round);
                    const colIndex = input.closest('td').cellIndex - 1;
                    const pickNumber = ((round - 1) * owners.length) + (colIndex + 1);
                    const owner = owners[colIndex];
                    const pos = getPlayerPrimaryPosition(player);
                    
                    const pickData = {
                        player: player.name,
                        rank: player.rank,
                        team: player.team,
                        position: pos,
                        pickNumber: pickNumber,
                        round: round,
                        owner: owner,
                        age: player.age || 25 // Default age if not available
                    };
                    
                    draftData.push(pickData);
                    teamData[owner].push(pickData);
                    teamTrends[owner].picks++;
                    teamTrends[owner].positions[pos]++;
                    teamTrends[owner].recentPicks.push(pickData);
                    positionData[pos]++;
                }
            }
        });
        
        // Sort draft data by pick number
        draftData.sort((a, b) => a.pickNumber - b.pickNumber);
        
        // Calculate position scarcity based on your league settings
        const totalExpectedPicks = 250; // 10 teams * 25 rounds
        const expectedByPosition = {
            C: LEAGUE_SETTINGS.rosterPositions.centers * 10, // 4 * 10 = 40
            LW: LEAGUE_SETTINGS.rosterPositions.leftWings * 10, // 4 * 10 = 40
            RW: LEAGUE_SETTINGS.rosterPositions.rightWings * 10, // 4 * 10 = 40
            D: LEAGUE_SETTINGS.rosterPositions.defensemen * 10, // 6 * 10 = 60
            G: LEAGUE_SETTINGS.rosterPositions.goalies * 10 // 2 * 10 = 20
        };
        
        const scarcity = {
            C: Math.round((positionData.C / expectedByPosition.C) * 100),
            LW: Math.round((positionData.LW / expectedByPosition.LW) * 100),
            RW: Math.round((positionData.RW / expectedByPosition.RW) * 100),
            D: Math.round((positionData.D / expectedByPosition.D) * 100),
            G: Math.round((positionData.G / expectedByPosition.G) * 100)
        };
        
        // Generate scarcity alerts based on your league settings
        const scarcityAlerts = [];
        if (scarcity.D > 80) scarcityAlerts.push("Defensemen running thin - only 6 required per team");
        if (scarcity.G > 70) scarcityAlerts.push("Goalies getting scarce - only 2 required per team");
        if (scarcity.C > 85) scarcityAlerts.push("Centers running thin - 4 required per team");
        if (scarcity.LW > 85) scarcityAlerts.push("Left Wings running thin - 4 required per team");
        if (scarcity.RW > 85) scarcityAlerts.push("Right Wings running thin - 4 required per team");
        
        // Analyze team strategies
        const teamStrategies = owners.map(owner => {
            const data = teamTrends[owner];
            const recentPicks = data.recentPicks.slice(-3);
            const positionCounts = data.positions;
            
            let strategy = "Balanced";
            let prediction = "Will continue balanced approach";
            
            // Analyze drafting pattern
            if (data.picks > 8) {
                strategy = "Aggressive";
                prediction = "Likely to continue aggressive drafting";
            } else if (data.picks < 6) {
                strategy = "Conservative";
                prediction = "Waiting for value, may pick soon";
            }
            
            // Position preference analysis
            const maxPos = Object.entries(positionCounts).reduce((a, b) => positionCounts[a[0]] > positionCounts[b[0]] ? a : b);
            if (maxPos[1] >= 3) {
                strategy += ` (${maxPos[0]} heavy)`;
                prediction = `Needs ${maxPos[0] === 'C' ? 'centers' : maxPos[0] === 'D' ? 'defensemen' : maxPos[0] === 'G' ? 'goalies' : 'forwards'}`;
            }
            
            return {
                owner: owner,
                picks: data.picks,
                strategy: strategy,
                prediction: prediction
            };
        });
        
        // Value pick analysis
        const valuePicks = {
            steals: [],
            reaches: []
        };
        
        draftData.forEach(pick => {
            const valueDiff = pick.pickNumber - pick.rank;
            if (valueDiff > 10) {
                valuePicks.steals.push({
                    player: pick.player,
                    rank: pick.rank,
                    pick: pick.pickNumber,
                    value: valueDiff
                });
            } else if (valueDiff < -5) {
                valuePicks.reaches.push({
                    player: pick.player,
                    rank: pick.rank,
                    pick: pick.pickNumber,
                    reach: Math.abs(valueDiff)
                });
            }
        });
        
        // Sort steals by value
        valuePicks.steals.sort((a, b) => b.value - a.value);
        
        // Update team status based on pick count
        owners.forEach(owner => {
            const picks = teamTrends[owner].picks;
            if (picks > 8) {
                teamTrends[owner].status = 'aggressive';
            } else if (picks < 6) {
                teamTrends[owner].status = 'conservative';
            } else {
                teamTrends[owner].status = 'balanced';
            }
        });
        
        // Positional run detection
        const positionalRuns = [];
        const recentPicks = draftData.slice(-10); // Last 10 picks
        const positionCounts = {};
        
        recentPicks.forEach(pick => {
            positionCounts[pick.position] = (positionCounts[pick.position] || 0) + 1;
        });
        
        Object.entries(positionCounts).forEach(([pos, count]) => {
            if (count >= 3) {
                const positionNames = { C: 'Centers', LW: 'Left Wings', RW: 'Right Wings', D: 'Defensemen', G: 'Goalies' };
                let recommendation = "Continue the run or pivot to another position";
                
                if (pos === 'D' && count >= 4) {
                    recommendation = "Defensemen run may be ending - consider forwards";
                } else if (pos === 'G' && count >= 2) {
                    recommendation = "Goalies running hot - wait for better value";
                }
                
                positionalRuns.push({
                    position: positionNames[pos],
                    count: count,
                    rounds: Math.ceil(count / owners.length),
                    recommendation: recommendation
                });
            }
        });
        
        // Keeper league insights
        const youngPlayers = draftData.filter(pick => pick.age < 25).length;
        const agingStars = draftData.filter(pick => pick.age > 30).length;
        
        let keeperStrategy = "League favors balanced approach";
        if (youngPlayers > agingStars * 1.5) {
            keeperStrategy = "League heavily favors young players - aging stars undervalued";
        } else if (agingStars > youngPlayers * 1.2) {
            keeperStrategy = "League favors proven veterans - young players undervalued";
        }
        
        // Generate actionable recommendations
        const recommendations = [];
        const currentPick = draftData.length + 1;
        const currentRound = Math.ceil(currentPick / owners.length);
        
        // Position scarcity recommendations based on your league settings
        if (scarcity.D > 75) {
            recommendations.push({
                priority: "HIGH PRIORITY",
                action: "Consider taking a defenseman soon",
                reasoning: `Defensemen ${scarcity.D}% drafted - need 6 per team`
            });
        }
        
        if (scarcity.G > 60) {
            recommendations.push({
                priority: "HIGH PRIORITY", 
                action: "Monitor goalie availability",
                reasoning: `Goalies ${scarcity.G}% drafted - only 2 per team needed`
            });
        }
        
        if (scarcity.C > 80) {
            recommendations.push({
                priority: "MEDIUM PRIORITY",
                action: "Consider center depth",
                reasoning: `Centers ${scarcity.C}% drafted - need 4 per team`
            });
        }
        
        if (scarcity.LW > 80 || scarcity.RW > 80) {
            recommendations.push({
                priority: "MEDIUM PRIORITY",
                action: "Monitor wing availability",
                reasoning: `Wings ${Math.max(scarcity.LW, scarcity.RW)}% drafted - need 4 each per team`
            });
        }
        
        // Value recommendations
        if (valuePicks.steals.length > 0) {
            recommendations.push({
                priority: "OPPORTUNITY",
                action: "Look for similar value picks",
                reasoning: `${valuePicks.steals.length} steals identified - league may be undervaluing certain players`
            });
        }
        
        // Positional run recommendations
        if (positionalRuns.length > 0) {
            positionalRuns.forEach(run => {
                recommendations.push({
                    priority: "TREND ALERT",
                    action: `Monitor ${run.position} run`,
                    reasoning: `${run.count} ${run.position.toLowerCase()} in recent picks - ${run.recommendation}`
                });
            });
        }
        
        // Team needs analysis based on your league settings
        const lukeData = teamTrends['Luke (1st)'];
        if (lukeData) {
            const needs = [];
            const required = LEAGUE_SETTINGS.rosterPositions;
            
            if (lukeData.positions.G < required.goalies) needs.push(`${required.goalies - lukeData.positions.G} goalie${required.goalies - lukeData.positions.G > 1 ? 's' : ''}`);
            if (lukeData.positions.D < required.defensemen) needs.push(`${required.defensemen - lukeData.positions.D} defenseman${required.defensemen - lukeData.positions.D > 1 ? 's' : ''}`);
            if (lukeData.positions.C < required.centers) needs.push(`${required.centers - lukeData.positions.C} center${required.centers - lukeData.positions.C > 1 ? 's' : ''}`);
            if (lukeData.positions.LW < required.leftWings) needs.push(`${required.leftWings - lukeData.positions.LW} left wing${required.leftWings - lukeData.positions.LW > 1 ? 's' : ''}`);
            if (lukeData.positions.RW < required.rightWings) needs.push(`${required.rightWings - lukeData.positions.RW} right wing${required.rightWings - lukeData.positions.RW > 1 ? 's' : ''}`);
            
            if (needs.length > 0) {
                recommendations.push({
                    priority: "YOUR NEEDS",
                    action: `Focus on ${needs.slice(0, 2).join(' or ')}`,
                    reasoning: `Your team needs: ${needs.join(', ')}`
                });
            }
        }
        
        // Draft momentum analysis
        const momentumAnalysis = analyzeDraftMomentum(draftData);
        
        // League meta analysis
        const metaAnalysis = analyzeLeagueMeta(draftData, teamTrends);
        
        // Enhanced team predictions
        const teamPredictions = generateTeamPredictions(teamTrends, draftData);
        
        return {
            positionTrends: {
                C: positionData.C,
                LW: positionData.LW,
                RW: positionData.RW,
                D: positionData.D,
                G: positionData.G,
                forwards: positionData.C + positionData.LW + positionData.RW
            },
            scarcity: scarcity,
            scarcityAlerts: scarcityAlerts,
            teamStrategies: teamStrategies,
            valuePicks: valuePicks,
            positionalRuns: positionalRuns,
            keeperInsights: {
                youngPlayers: youngPlayers,
                agingStars: agingStars,
                strategy: keeperStrategy
            },
            recommendations: recommendations.slice(0, 5), // Top 5 recommendations
            teamTrends: teamTrends,
            momentumAnalysis: momentumAnalysis,
            metaAnalysis: metaAnalysis,
            teamPredictions: teamPredictions,
            expectedByPosition: expectedByPosition
        };
    }
    
    function analyzeDraftMomentum(draftData) {
        if (draftData.length < 10) return { trend: "Insufficient data", prediction: "Need more picks to analyze momentum" };
        
        const recentPicks = draftData.slice(-10);
        const earlierPicks = draftData.slice(-20, -10);
        
        // Analyze position momentum
        const recentPositions = recentPicks.map(p => p.position);
        const earlierPositions = earlierPicks.map(p => p.position);
        
        const recentCounts = {};
        const earlierCounts = {};
        
        recentPositions.forEach(pos => recentCounts[pos] = (recentCounts[pos] || 0) + 1);
        earlierPositions.forEach(pos => earlierCounts[pos] = (earlierCounts[pos] || 0) + 1);
        
        // Find momentum shifts
        const momentumShifts = [];
        Object.keys(recentCounts).forEach(pos => {
            const recent = recentCounts[pos] || 0;
            const earlier = earlierCounts[pos] || 0;
            const change = recent - earlier;
            
            if (Math.abs(change) >= 2) {
                const direction = change > 0 ? 'accelerating' : 'slowing';
                momentumShifts.push({
                    position: pos,
                    change: change,
                    direction: direction
                });
            }
        });
        
        // Predict next trend
        let prediction = "Balanced drafting expected";
        if (momentumShifts.length > 0) {
            const strongestShift = momentumShifts.reduce((a, b) => Math.abs(a.change) > Math.abs(b.change) ? a : b);
            prediction = `${strongestShift.position} momentum ${strongestShift.direction} - expect ${strongestShift.direction === 'accelerating' ? 'more' : 'fewer'} ${strongestShift.position} picks`;
        }
        
        return {
            trend: momentumShifts.length > 0 ? "Momentum shifts detected" : "Stable momentum",
            shifts: momentumShifts,
            prediction: prediction
        };
    }
    
    function analyzeLeagueMeta(draftData, teamTrends) {
        // Analyze overall league preferences
        const totalPicks = draftData.length;
        const positionDistribution = {
            C: (draftData.filter(p => p.position === 'C').length / totalPicks) * 100,
            LW: (draftData.filter(p => p.position === 'LW').length / totalPicks) * 100,
            RW: (draftData.filter(p => p.position === 'RW').length / totalPicks) * 100,
            D: (draftData.filter(p => p.position === 'D').length / totalPicks) * 100,
            G: (draftData.filter(p => p.position === 'G').length / totalPicks) * 100,
            forwards: (draftData.filter(p => ['C', 'LW', 'RW'].includes(p.position)).length / totalPicks) * 100
        };
        
        // Analyze drafting speed
        const aggressiveTeams = Object.values(teamTrends).filter(t => t.picks > 8).length;
        const conservativeTeams = Object.values(teamTrends).filter(t => t.picks < 6).length;
        
        let metaDescription = "Balanced league meta";
        if (aggressiveTeams > conservativeTeams * 1.5) {
            metaDescription = "Aggressive drafting meta - teams picking fast";
        } else if (conservativeTeams > aggressiveTeams * 1.5) {
            metaDescription = "Conservative drafting meta - teams waiting for value";
        }
        
        // Position preference analysis based on your league settings
        let positionMeta = "Balanced position preferences";
        const expectedDistribution = {
            C: 16, // 4 centers * 10 teams / 250 picks * 100
            LW: 16, // 4 LW * 10 teams / 250 picks * 100
            RW: 16, // 4 RW * 10 teams / 250 picks * 100
            D: 24, // 6 D * 10 teams / 250 picks * 100
            G: 8   // 2 G * 10 teams / 250 picks * 100
        };
        
        if (positionDistribution.D > expectedDistribution.D * 1.2) {
            positionMeta = "Defensemen-heavy league - forwards undervalued";
        } else if (positionDistribution.forwards > 60) {
            positionMeta = "Forward-heavy league - defensemen undervalued";
        } else if (positionDistribution.G > expectedDistribution.G * 1.5) {
            positionMeta = "Goalie-heavy league - skaters undervalued";
        }
        
        return {
            description: metaDescription,
            positionMeta: positionMeta,
            distribution: positionDistribution,
            expectedDistribution: expectedDistribution,
            aggressiveTeams: aggressiveTeams,
            conservativeTeams: conservativeTeams
        };
    }
    
    function generateTeamPredictions(teamTrends, draftData) {
        const predictions = {};
        const required = LEAGUE_SETTINGS.rosterPositions;
        
        owners.forEach(owner => {
            const teamData = teamTrends[owner];
            const predictions_for_owner = [];
            
            // Skip if teamData is undefined or missing positions
            if (!teamData || !teamData.positions) {
                predictions[owner] = predictions_for_owner;
                return;
            }
            
            // Predict next position needs based on league settings
            if (required.goalies && teamData.positions.G < required.goalies) {
                predictions_for_owner.push({
                    type: "Position Need",
                    prediction: `Needs ${required.goalies - teamData.positions.G} goalie${required.goalies - teamData.positions.G > 1 ? 's' : ''}`,
                    confidence: teamData.positions.G === 0 ? "High" : "Medium",
                    reasoning: `Only ${teamData.positions.G}/${required.goalies} goalies drafted`
                });
            }
            
            if (required.defensemen && teamData.positions.D < required.defensemen) {
                predictions_for_owner.push({
                    type: "Position Need", 
                    prediction: `Needs ${required.defensemen - teamData.positions.D} defenseman${required.defensemen - teamData.positions.D > 1 ? 's' : ''}`,
                    confidence: teamData.positions.D < 2 ? "High" : "Medium",
                    reasoning: `Only ${teamData.positions.D}/${required.defensemen} defensemen drafted`
                });
            }
            
            if (required.centers && teamData.positions.C < required.centers) {
                predictions_for_owner.push({
                    type: "Position Need",
                    prediction: `Needs ${required.centers - teamData.positions.C} center${required.centers - teamData.positions.C > 1 ? 's' : ''}`,
                    confidence: "Medium",
                    reasoning: `Only ${teamData.positions.C}/${required.centers} centers drafted`
                });
            }
            
            if (required.leftWings && teamData.positions.LW < required.leftWings) {
                predictions_for_owner.push({
                    type: "Position Need",
                    prediction: `Needs ${required.leftWings - teamData.positions.LW} left wing${required.leftWings - teamData.positions.LW > 1 ? 's' : ''}`,
                    confidence: "Medium",
                    reasoning: `Only ${teamData.positions.LW}/${required.leftWings} left wings drafted`
                });
            }
            
            if (required.rightWings && teamData.positions.RW < required.rightWings) {
                predictions_for_owner.push({
                    type: "Position Need",
                    prediction: `Needs ${required.rightWings - teamData.positions.RW} right wing${required.rightWings - teamData.positions.RW > 1 ? 's' : ''}`,
                    confidence: "Medium",
                    reasoning: `Only ${teamData.positions.RW}/${required.rightWings} right wings drafted`
                });
            }
            
            // Predict drafting behavior
            if (teamData.picks > 8) {
                predictions_for_owner.push({
                    type: "Behavior",
                    prediction: "Will continue aggressive drafting",
                    confidence: "High",
                    reasoning: "Already drafted 8+ players"
                });
            } else if (teamData.picks < 6) {
                predictions_for_owner.push({
                    type: "Behavior",
                    prediction: "May pick soon - waiting for value",
                    confidence: "Medium", 
                    reasoning: "Conservative drafting pattern"
                });
            }
            
            predictions[owner] = predictions_for_owner.slice(0, 3); // Limit to top 3 predictions
        });
        
        return predictions;
    }
    
    function showPositionAnalysis() {
        const container = document.getElementById('positionAnalysis');
        if (!container) return;
        
        const balances = analyzePositionBalance();
        
        // Create position distribution chart
        const chartContainer = document.getElementById('positionChart');
        if (chartContainer) {
            chartContainer.innerHTML = '<h4 class="text-md font-semibold text-white mb-2">Team Position Distribution</h4>';
        }
        
        if (chartContainer) {
            owners.forEach(owner => {
                const balance = balances[owner];
                const total = balance.total;
                if (total > 0) {
                    const fPercent = Math.round((balance.F / total) * 100);
                    const dPercent = Math.round((balance.D / total) * 100);
                    const gPercent = Math.round((balance.G / total) * 100);
                    
                    const teamDiv = document.createElement('div');
                    teamDiv.className = 'mb-3 p-3 bg-gray-800 rounded-lg';
                    teamDiv.innerHTML = `
                        <div class="flex justify-between items-center mb-2">
                            <span class="font-semibold text-white">${owner}</span>
                            <span class="text-sm text-gray-400">${total} players</span>
                        </div>
                        <div class="flex gap-1 mb-2">
                            <div class="flex-1 bg-red-500/20 rounded text-center text-xs py-1 text-red-300">F: ${fPercent}%</div>
                            <div class="flex-1 bg-blue-500/20 rounded text-center text-xs py-1 text-blue-300">D: ${dPercent}%</div>
                            <div class="flex-1 bg-yellow-500/20 rounded text-center text-xs py-1 text-yellow-300">G: ${gPercent}%</div>
                        </div>
                    `;
                    chartContainer.appendChild(teamDiv);
                }
            });
        }
        
        // Generate recommendations
        const recommendationsContainer = document.getElementById('recommendationsList');
        if (recommendationsContainer) {
            recommendationsContainer.innerHTML = '';
        }
        
        if (recommendationsContainer) {
            owners.forEach(owner => {
                const balance = balances[owner];
                const total = balance.total;
                if (total > 0) {
                    const fRatio = balance.F / total;
                    const dRatio = balance.D / total;
                    const gRatio = balance.G / total;
                    
                    let recommendation = '';
                    if (gRatio > 0.15) {
                        recommendation = '⚠️ Too many goalies - focus on forwards/defensemen';
                    } else if (fRatio < 0.5) {
                        recommendation = '📈 Need more forwards - prioritize F picks';
                    } else if (dRatio < 0.2) {
                        recommendation = '🛡️ Need more defensemen - consider D picks';
        } else {
                        recommendation = '✅ Well balanced roster';
                    }
                    
                    if (recommendation) {
                        const recDiv = document.createElement('div');
                        recDiv.className = 'p-2 bg-gray-800 rounded text-sm';
                        recDiv.innerHTML = `<strong>${owner}:</strong> ${recommendation}`;
                        recommendationsContainer.appendChild(recDiv);
                    }
                }
            });
        }
    }
    
    function showDraftTrends() {
        const container = document.getElementById('draftTrends');
        const trendsContent = document.getElementById('trendsContent');
        if (!trendsContent) return;
        
        // Analyze draft trends
        const positionTrends = { C: 0, LW: 0, RW: 0, D: 0, G: 0 };
        const teamTrends = {};
        
        owners.forEach(owner => teamTrends[owner] = 0);
        
        document.querySelectorAll('#tableBody .player-input').forEach(input => {
            if (input.value.trim()) {
                const player = findPlayerByName(input.value);
                if (player) {
                    const pos = getPlayerPrimaryPosition(player);
                    positionTrends[pos]++;
                    
                    const row = input.closest('tr');
                    const colIndex = input.closest('td').cellIndex - 1;
                    const owner = owners[colIndex];
                    teamTrends[owner]++;
                }
            }
        });
        
        trendsContent.innerHTML = `
            <div class="space-y-4">
                <div class="p-3 bg-gray-800 rounded-lg">
                    <h4 class="font-semibold text-white mb-2">Position Trends</h4>
                    <div class="space-y-2">
                        <div class="flex justify-between">
                            <span class="text-red-300">Forwards:</span>
                            <span class="text-white">${positionTrends.C + positionTrends.LW + positionTrends.RW}</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-blue-300">Defensemen:</span>
                            <span class="text-white">${positionTrends.D}</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-yellow-300">Goalies:</span>
                            <span class="text-white">${positionTrends.G}</span>
                        </div>
                    </div>
                </div>
                
                <div class="p-3 bg-gray-800 rounded-lg">
                    <h4 class="font-semibold text-white mb-2">Team Activity</h4>
                    <div class="space-y-1">
                        ${Object.entries(teamTrends).map(([owner, count]) => 
                            `<div class="flex justify-between text-sm">
                                <span class="text-gray-300">${owner}:</span>
                                <span class="text-white">${count} picks</span>
                            </div>`
                        ).join('')}
                    </div>
                </div>
            </div>
        `;
    }
    

    // --- EXPORT/IMPORT FUNCTIONALITY ---
    function exportDraft() {
        const draftData = {
            year: DRAFT_YEAR,
            owners: owners,
            picks: getCurrentDraftState(),
            timestamp: new Date().toISOString(),
            stats: draftStats
        };
        
        const blob = new Blob([JSON.stringify(draftData, null, 2)], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `fantasy-draft-${DRAFT_YEAR}-${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    function importDraft(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                
                if (data.year && data.owners && data.picks) {
                    // Restore draft state
                    restoreDraftState(data.picks);
                    
                    // Save to history
                    saveDraftStateToHistory();
                    
                    alert('Draft imported successfully!');
                } else {
                    alert('Invalid draft file format.');
                }
            } catch (error) {
                alert('Error reading draft file: ' + error.message);
            }
        };
        reader.readAsText(file);
    }
    
    // --- STATE MANAGEMENT (LOCALSTORAGE) ---
    function saveDraftState() {
        const draftData = {};
        document.querySelectorAll('#tableBody tr').forEach(row => {
            const round = parseInt(row.dataset.round);
            draftData[round] = [];
            row.querySelectorAll('input[type="text"]').forEach(input => {
                draftData[round].push(input.value);
            });
        });
        localStorage.setItem(STORAGE_KEY, JSON.stringify(draftData));
    }
    function loadDraftState() {
        const savedData = localStorage.getItem(STORAGE_KEY);
        try {
            if (savedData) return JSON.parse(savedData);
        } catch (e) {
            console.error("Failed to parse saved draft data.", e);
        }
        return initialPrefilledData;
    }

    // --- UI & RENDERING ---
    function renderTableBody(draftData) {
        const tbody = document.getElementById('tableBody');
        tbody.innerHTML = '';
        const frag = document.createDocumentFragment();

        for (let round = 1; round <= numRounds; round++) {
            const tr = document.createElement('tr');
            tr.className = 'row';
            tr.dataset.round = round;

            const roundTd = document.createElement('td');
            roundTd.className = 'cell';
            roundTd.style.cssText = 'background-color: #374151; font-weight: 600; color: #e5e7eb;';
            roundTd.textContent = String(round);
            tr.appendChild(roundTd);

            const picks = draftData[round] || [];
            for (let c = 0; c < owners.length; c++) {
                const td = document.createElement('td');
                td.className = 'cell';
                
                const wrapper = document.createElement('div');
                wrapper.className = 'input-wrapper';

                const input = document.createElement('input');
                input.type = 'text';
                const val = picks[c] || '';
                
                if (val === '') {
                    input.className = 'placeholder-input';
                    input.placeholder = `Pick ${((round - 1) * owners.length) + (c + 1)}`;
                } else {
                    input.className = 'player-input';
                    input.value = val;
                    const player = findPlayerByName(val);
                    if (player) {
                        const pos = getPlayerPrimaryPosition(player);
                        input.classList.add(positionColors[pos]);
                        
                        // Add position-based cell coloring
                        if (pos === 'C' || pos === 'LW' || pos === 'RW') {
                            td.classList.add('cell-forward');
                        } else if (pos === 'D') {
                            td.classList.add('cell-defense');
                        } else if (pos === 'G') {
                            td.classList.add('cell-goalie');
                        }
                        
                        input.title = `#${player.rank} ${player.name} (${player.team} - ${player.pos})`;
                    }
                }
                
                const clearBtn = document.createElement('span');
                clearBtn.innerHTML = '&times;';
                clearBtn.className = 'clear-btn';

                wrapper.appendChild(input);
                wrapper.appendChild(clearBtn);
                td.appendChild(wrapper);
                tr.appendChild(td);
            }
            frag.appendChild(tr);
        }
        tbody.appendChild(frag);
    }
    
    // Centralized state management for robust syncing
    let updateQueue = [];
    let isUpdating = false;
    let lastUpdateTime = 0;
    const UPDATE_DEBOUNCE_MS = 100; // Prevent rapid successive updates
    
    function updateAllUI() {
        console.log('=== UPDATE ALL UI DEBUG ===');
        console.log('Actual draft picks (in positions):', draftStats.totalPicks);
        console.log('Selected players count (all selected):', selectedPlayers.size);
        
        // Add to update queue and process with debouncing
        queueUIUpdate(() => {
            try {
                updateSelectedPlayersSet();
                updatePlayerCount();
                updateDraftProgress(); // Update draft stats BEFORE validation
                
                // Validate state consistency after updating draft progress
                validateStateConsistency();
                
                applyPositionBalanceWarnings();
                updateTableRowStyling();
                generateDraftPrompts(); // Generate contextual prompts
                
                // Update current tab content
                updateCurrentTabContent();
                
                // Update floating button states
                updateFloatingButtonStates();
                
                // Trigger auto-save
                triggerAutoSave();
                
                console.log('=== END UPDATE ALL UI DEBUG ===');
            } catch (error) {
                console.error('Error in updateAllUI:', error);
                // Attempt to recover by re-syncing state
                recoverFromSyncError();
            }
        });
    }
    
    // Queue UI updates to prevent race conditions
    function queueUIUpdate(updateFunction) {
        updateQueue.push(updateFunction);
        processUpdateQueue();
    }
    
    // Process update queue with debouncing
    function processUpdateQueue() {
        if (isUpdating) return;
        
        const now = Date.now();
        if (now - lastUpdateTime < UPDATE_DEBOUNCE_MS) {
            setTimeout(() => processUpdateQueue(), UPDATE_DEBOUNCE_MS - (now - lastUpdateTime));
            return;
        }
        
        isUpdating = true;
        lastUpdateTime = now;
        
        // Process all queued updates
        const updates = [...updateQueue];
        updateQueue = [];
        
        updates.forEach(update => {
            try {
                update();
            } catch (error) {
                console.error('Error in queued update:', error);
            }
        });
        
        isUpdating = false;
        
        // Check if more updates were queued during processing
        if (updateQueue.length > 0) {
            setTimeout(() => processUpdateQueue(), UPDATE_DEBOUNCE_MS);
        }
    }
    
    // Validate that draft board and selectedPlayers are in sync
    function validateStateConsistency() {
        const draftBoardPlayers = new Set();
        document.querySelectorAll('#tableBody .player-input').forEach(input => {
            if (input.value.trim()) {
                const player = findPlayerByName(input.value.trim());
                if (player) {
                    draftBoardPlayers.add(player.name);
                }
            }
        });
        
        // Check for discrepancies
        const selectedPlayersArray = Array.from(selectedPlayers);
        const draftBoardPlayersArray = Array.from(draftBoardPlayers);
        
        const missingFromSelected = draftBoardPlayersArray.filter(name => !selectedPlayers.has(name));
        const missingFromDraftBoard = selectedPlayersArray.filter(name => !draftBoardPlayers.has(name));
        
        // Count actual draft picks (players in specific positions)
        const actualDraftPicks = Array.from(document.querySelectorAll('#tableBody .player-input')).filter(input => input.value.trim()).length;
        
        if (missingFromSelected.length > 0 || missingFromDraftBoard.length > 0) {
            console.warn('State inconsistency detected:', {
                missingFromSelected,
                missingFromDraftBoard,
                selectedPlayersCount: selectedPlayers.size,
                draftBoardPlayersCount: draftBoardPlayers.size,
                actualDraftPicks: actualDraftPicks
            });
            
            // Fix the inconsistency by updating selectedPlayers to match draft board
            selectedPlayers.clear();
            draftBoardPlayers.forEach(name => selectedPlayers.add(name));
            
            console.log('State synchronized - selectedPlayers updated to match draft board');
        } else {
            console.log('State validation passed - draft board and selectedPlayers are in sync');
            console.log('Draft stats:', {
                actualDraftPicks: actualDraftPicks,
                selectedPlayersCount: selectedPlayers.size,
                draftBoardPlayersCount: draftBoardPlayers.size
            });
        }
    }
    
    // Recovery function for sync errors
    function recoverFromSyncError() {
        console.log('Attempting to recover from sync error...');
        try {
            // Force a complete state rebuild
            updateSelectedPlayersSet();
            updateCurrentTabContent();
        } catch (error) {
            console.error('Recovery failed:', error);
        }
    }
    
    // Force complete sync refresh - useful for debugging or manual recovery
    function forceSyncRefresh() {
        console.log('Forcing complete sync refresh...');
        try {
            // Clear any pending updates
            updateQueue = [];
            isUpdating = false;
            
            // Force state validation and rebuild
            validateStateConsistency();
            updateAllUI();
            
            console.log('Sync refresh completed successfully');
        } catch (error) {
            console.error('Sync refresh failed:', error);
        }
    }
    
    // Add global function for manual sync refresh (useful for debugging)
    window.forceSyncRefresh = forceSyncRefresh;
    
    function updateTableRowStyling() {
        document.querySelectorAll('#tableBody tr').forEach((row, index) => {
            // Remove existing classes
            row.classList.remove('table-row-even', 'table-row-odd', 'current-pick-row');
            
            // Add alternating row colors
            row.classList.add(index % 2 === 0 ? 'table-row-even' : 'table-row-odd');
            
            // Draft phase styling removed
            
            // Highlight current pick row
            const currentPick = getCurrentPickNumber();
            const round = parseInt(row.dataset.round);
            const rowStartPick = ((round - 1) * owners.length) + 1;
            const rowEndPick = round * owners.length;
            if (currentPick >= rowStartPick && currentPick <= rowEndPick) {
                row.classList.add('current-pick-row');
            }
        });
    }
    
    
    function triggerAutoSave() {
        // Clear existing timeout
        if (autoSaveTimeout) {
            clearTimeout(autoSaveTimeout);
        }
        
        // Auto-save after 1 second of inactivity (silently)
        autoSaveTimeout = setTimeout(() => {
            saveDraftState();
        }, 1000);
    }

    function updateSelectedPlayersSet() {
        selectedPlayers.clear();
        document.querySelectorAll('#tableBody .player-input').forEach(input => {
            if (input.value.trim()) {
                const player = findPlayerByName(input.value);
                if (player) selectedPlayers.add(player.name);
            }
        });
    }

    function updatePlayerCount() {
        document.getElementById('playerCount').textContent = selectedPlayers.size;
    }

    function updateBestAvailablePanel() {
        const panel = document.getElementById('bestAvailableList');
        panel.innerHTML = '';
        const available = playerRankings
            .filter(p => !selectedPlayers.has(p.name))
            .slice(0, 20);

        if (available.length === 0) {
            panel.innerHTML = '<p class="text-gray-400 text-sm">All players selected!</p>';
            return;
        }

        available.forEach(player => {
            const div = document.createElement('div');
            div.className = 'best-available-player';
            const pos = getPlayerPrimaryPosition(player);
            div.innerHTML = `
                <span class="player-rank">#${player.rank}</span>
                <span>${player.name}</span>
                <span class="player-team">${player.team}</span>
                <span class="player-pos ${positionTextColors[pos]}">${player.pos}</span>
            `;
            panel.appendChild(div);
        });
    }

    // --- PLAYER SELECTION LOGIC ---
    function handlePlayerSelection(input, player) {
        try {
            // Save state to history before making changes
            saveDraftStateToHistory();
            
            // Clear old player if one was selected
            const oldPlayerName = input.dataset.lastValue;
            if (oldPlayerName && findPlayerByName(oldPlayerName)) {
                selectedPlayers.delete(findPlayerByName(oldPlayerName).name);
            }
            
            // Clear previous color classes
            input.classList.remove(...Object.values(positionColors));
            const cellTdClear = input.closest('td');
            if (cellTdClear) cellTdClear.classList.remove(...Object.values(positionColors));

            // Set new player
            input.value = player.name;
            input.dataset.lastValue = player.name;
            input.className = 'player-input';
            const pos = getPlayerPrimaryPosition(player);
            input.classList.add(positionColors[pos]);
            
            const cellTdSelect = input.closest('td');
            if (cellTdSelect) {
                // Remove old position classes
                cellTdSelect.classList.remove('cell-forward', 'cell-defense', 'cell-goalie');
                
                // Add new position-based cell coloring
                if (pos === 'C' || pos === 'LW' || pos === 'RW') {
                    cellTdSelect.classList.add('cell-forward');
                } else if (pos === 'D') {
                    cellTdSelect.classList.add('cell-defense');
                } else if (pos === 'G') {
                    cellTdSelect.classList.add('cell-goalie');
                }
            }
            
            input.title = `#${player.rank} ${player.name} (${player.team} - ${player.pos})`;
            
            // Add to selected players set
            selectedPlayers.add(player.name);
            
            // Hide dropdown
            hideDropdown();
            
            // Use centralized update system
            queueUIUpdate(() => {
                updateAllUI();
                saveDraftState();
            });
            
        } catch (error) {
            console.error('Error in handlePlayerSelection:', error);
            // Attempt to recover
            recoverFromSyncError();
        }
    }

    function handlePlayerClear(input) {
        try {
            // Save state to history before making changes
            saveDraftStateToHistory();
            
            const oldPlayerName = input.value;
            if (oldPlayerName && findPlayerByName(oldPlayerName)) {
                selectedPlayers.delete(findPlayerByName(oldPlayerName).name);
            }
            
            input.value = '';
            input.dataset.lastValue = '';
            input.className = 'placeholder-input';
            input.title = '';
            input.classList.remove(...Object.values(positionColors));
            
            const cellTd = input.closest('td');
            if (cellTd) {
                // Remove position-based cell coloring
                cellTd.classList.remove('cell-forward', 'cell-defense', 'cell-goalie');
            }
            
            const round = parseInt(input.closest('tr').dataset.round);
            const colIndex = input.closest('td').cellIndex;
            input.placeholder = `Pick ${((round - 1) * owners.length) + (colIndex)}`;

            // Use centralized update system
            queueUIUpdate(() => {
                updateAllUI();
                saveDraftState();
            });
            
        } catch (error) {
            console.error('Error in handlePlayerClear:', error);
            // Attempt to recover
            recoverFromSyncError();
        }
    }

    function createDropdown(cell, input) {
        const portal = document.getElementById('dropdownPortal');
        let dropdown = document.createElement('div');
        dropdown.className = 'player-dropdown';
        portal.appendChild(dropdown);
        
        const show = (searchTerm = '') => {
            if (activeDropdown && activeDropdown !== dropdown) {
                activeDropdown.style.display = 'none';
            }
            activeDropdown = dropdown;
            
            // Filter available players by search term
            const availablePlayers = playerRankings.filter(p => !selectedPlayers.has(p.name));
            const filteredPlayers = searchTerm ? 
                availablePlayers.filter(p => p.name.toLowerCase().includes(searchTerm.toLowerCase())) :
                availablePlayers;
            const playersToShow = filteredPlayers.slice(0, 50);
            dropdown.innerHTML = '';

            playersToShow.forEach(player => {
                const option = document.createElement('div');
                option.className = 'player-option';
                
                const isSelected = selectedPlayers.has(player.name);
                const isCurrentPlayer = input.value === player.name;

                if (isSelected && !isCurrentPlayer) {
                    option.classList.add('disabled');
                }
                
                const pos = getPlayerPrimaryPosition(player);
                option.innerHTML = `
                    <span class="player-rank">#${player.rank}</span>
                    <span>${player.name}</span>
                    <span class="player-team">${player.team}</span>
                    <span class="player-pos ${positionTextColors[pos]}">${player.pos}</span>
                `;
                
                if (!isSelected || isCurrentPlayer) {
                    option.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        handlePlayerSelection(input, player);
                    });
                }
                dropdown.appendChild(option);
            });

            const cellRect = cell.getBoundingClientRect();
            dropdown.style.left = cellRect.left + 'px';
            dropdown.style.top = (cellRect.bottom + 2) + 'px';
            const desiredWidth = Math.max(cellRect.width, 360);
            dropdown.style.minWidth = cellRect.width + 'px';
            dropdown.style.width = desiredWidth + 'px';
            dropdown.style.display = playersToShow.length > 0 ? 'block' : 'none';
        };
        return { show, element: dropdown };
    }
    
    function hideDropdown() {
        if (activeDropdown) {
            activeDropdown.style.display = 'none';
            activeDropdown.innerHTML = '';
            activeDropdown.parentElement.removeChild(activeDropdown);
        }
        activeDropdown = null;
    }

    // --- SORTING LOGIC ---
    let currentSort = { column: 0, direction: 'asc' };
    function sortTable(columnIndex) {
        const tbody = document.getElementById('tableBody');
        const rows = Array.from(tbody.querySelectorAll('tr'));

        currentSort.direction = (currentSort.column === columnIndex && currentSort.direction === 'asc') ? 'desc' : 'asc';
        currentSort.column = columnIndex;

        rows.sort((a, b) => {
            const aVal = (columnIndex === 0) ? parseInt(a.cells[0].textContent) : a.cells[columnIndex]?.querySelector('input')?.value.trim() || '';
            const bVal = (columnIndex === 0) ? parseInt(b.cells[0].textContent) : b.cells[columnIndex]?.querySelector('input')?.value.trim() || '';
            
            if (columnIndex > 0) { // Handle empty cells for player columns
                if (aVal === '' && bVal !== '') return 1;
                if (aVal !== '' && bVal === '') return -1;
            }

            const modifier = currentSort.direction === 'asc' ? 1 : -1;
            if (aVal < bVal) return -1 * modifier;
            if (aVal > bVal) return 1 * modifier;
            return 0;
        });

        rows.forEach(row => tbody.appendChild(row));
        updateSortIndicators(columnIndex);
    }
    function updateSortIndicators(activeColumn) {
        document.querySelectorAll('th.th-sortable i').forEach((icon, index) => {
            const th = icon.closest('th');
            const col = parseInt(th.dataset.column);
            if (col === activeColumn) {
                icon.className = `fas fa-sort-${currentSort.direction === 'asc' ? 'up' : 'down'} text-blue-400 text-xs`;
            } else {
                icon.className = 'fas fa-sort thead-icon';
            }
        });
    }

    // --- FLOATING BUTTON STATES ---
    function updateFloatingButtonStates() {
        const floatingUndoBtn = document.getElementById('floatingUndoBtn');
        const floatingRedoBtn = document.getElementById('floatingRedoBtn');
        
        const canUndo = historyIndex > 0;
        const canRedo = historyIndex < draftHistory.length - 1;
        
        if (floatingUndoBtn) floatingUndoBtn.disabled = !canUndo;
        if (floatingRedoBtn) floatingRedoBtn.disabled = !canRedo;
    }

    // --- INITIALIZATION ---
    document.addEventListener('DOMContentLoaded', function() {
        // 1. Load data and build table
        const draftData = loadDraftState();
        renderTableBody(draftData);
        
        // Initialize draft history with current state
        forceSaveDraftStateToHistory();
        
        updateAllUI();

        // 2. Attach delegated event listeners
        const tableBody = document.getElementById('tableBody');
        tableBody.addEventListener('focusin', e => {
            if (e.target.matches('input[type="text"]')) {
                const input = e.target;
                input.dataset.lastValue = input.value; // Store value on focus
                const cell = input.closest('td');
                const { show, element } = createDropdown(cell, input);
                
                const handleInput = () => show(input.value);
                const handleKeyDown = (ev) => {
                    const options = Array.from(element.querySelectorAll('.player-option:not(.disabled)'));
                    if (!options.length) return;

                    let currentIndex = options.findIndex(opt => opt.classList.contains('highlighted'));

                    if (ev.key === 'ArrowDown') {
                        ev.preventDefault();
                        currentIndex = (currentIndex + 1) % options.length;
                    } else if (ev.key === 'ArrowUp') {
                        ev.preventDefault();
                        currentIndex = (currentIndex - 1 + options.length) % options.length;
                    } else if (ev.key === 'Enter') {
                        ev.preventDefault();
                        if (currentIndex > -1) options[currentIndex].dispatchEvent(new MouseEvent('mousedown'));
                    } else if (ev.key === 'Escape') {
                         hideDropdown();
                    } else if (ev.key === 'Tab') {
                        // Allow tab to work normally for accessibility
                        return;
                    } else if (ev.key.length === 1) {
                        // Character input - filter dropdown
                        ev.preventDefault();
                        const currentValue = input.value + ev.key;
                        input.value = currentValue;
                        show(currentValue);
                        
                        // Highlight first option after filtering
                        setTimeout(() => {
                            const newOptions = Array.from(element.querySelectorAll('.player-option:not(.disabled)'));
                            if (newOptions.length > 0) {
                                options.forEach(opt => opt.classList.remove('highlighted'));
                                newOptions[0].classList.add('highlighted');
                            }
                        }, 10);
                        return;
                    }
                    
                    options.forEach((opt, i) => opt.classList.toggle('highlighted', i === currentIndex));
                    if(currentIndex > -1) options[currentIndex].scrollIntoView({ block: 'nearest' });
                };

                const handleDocumentMouseDown = (ev) => {
                    // Close only if clicking outside the input and the dropdown
                    const clickedInsideDropdown = element && element.contains(ev.target);
                    const clickedInputItself = ev.target === input;
                    if (!clickedInsideDropdown && !clickedInputItself) {
                        input.removeEventListener('input', handleInput);
                        input.removeEventListener('keydown', handleKeyDown);
                        document.removeEventListener('mousedown', handleDocumentMouseDown);
                        hideDropdown();
                    }
                };

                const handleCleanup = () => {
                    // Cleanup listeners when input actually loses focus; do not forcibly hide here
                    input.removeEventListener('input', handleInput);
                    input.removeEventListener('keydown', handleKeyDown);
                    document.removeEventListener('mousedown', handleDocumentMouseDown);
                };
                
                input.addEventListener('input', handleInput);
                input.addEventListener('keydown', handleKeyDown);
                document.addEventListener('mousedown', handleDocumentMouseDown);
                input.addEventListener('blur', handleCleanup, { once: true });
                show(input.value);
            }
        });

        tableBody.addEventListener('click', e => {
            if (e.target.matches('.clear-btn')) {
                const input = e.target.previousElementSibling;
                handlePlayerClear(input);
            }
        });
        
        document.querySelectorAll('th.th-sortable').forEach(header => {
            header.addEventListener('click', () => sortTable(parseInt(header.dataset.column)));
        });

        document.getElementById('resetButton').addEventListener('click', () => {
            if (confirm('Are you sure you want to reset the entire draft board? This action cannot be undone.')) {
                localStorage.removeItem(STORAGE_KEY);
                window.location.reload();
            }
        });

        // --- NEW FEATURE EVENT LISTENERS ---
        
        // Main Tab Navigation
        document.querySelectorAll('.main-tab-button').forEach(btn => {
            btn.addEventListener('click', () => {
                const tabName = btn.dataset.mainTab;
                switchMainTab(tabName);
            });
        });
        
        // Tab Navigation (legacy - for sidebar if it exists)
        document.querySelectorAll('.tab-button').forEach(btn => {
            btn.addEventListener('click', () => {
                const tabName = btn.dataset.tab;
                switchTab(tabName);
            });
        });
        
        // Contextual prompts are now auto-generated
        

        // Floating Action Bar
        document.getElementById('floatingUndoBtn').addEventListener('click', undo);
        document.getElementById('floatingRedoBtn').addEventListener('click', redo);
        document.getElementById('floatingExportBtn').addEventListener('click', exportDraft);
        
        // Keyboard shortcuts for undo/redo
        document.addEventListener('keydown', (e) => {
            // Only trigger if not typing in an input field
            if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    undo();
                } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                    e.preventDefault();
                    redo();
                }
            }
        });

        
        // Both updateUndoRedoButtons and updateFloatingButtonStates will be called separately

        // 5. Initial animation
        const table = document.getElementById('keepersTable');
        table.style.opacity = '0';
        setTimeout(() => {
            table.style.transition = 'opacity 0.5s ease';
            table.style.opacity = '1';
        }, 100);
    });

    /* --- FUTURE IMPROVEMENTS (for a multi-file setup) ---
     *
     * 1.  Data Externalization: Move `playerRankings`, `owners`, and other config
     * into a separate `config.js` or even JSON files. This would allow for easier
     * year-over-year updates without touching the main application logic.
     * Example: Fetch rankings from `rankings-2026.json`.
     *
     * 2.  Team Roster View Panel: Add a toggle to the side panel to switch between
     * "Best Available" and a "Team Roster View". This view would dynamically
     * generate a list of players for each team, grouped by position.
     *
     * 3.  Live Collaboration: For a truly live draft experience, the current
     * localStorage approach would need to be replaced with a real-time backend
     * service like Firebase Realtime Database or a WebSocket server. This would
     * sync picks instantly across all users' browsers.
     *
     * 4.  Draft History/Archiving: Instead of one storage key, use a system that
     * allows saving multiple years of drafts. For example, a dropdown could
     * let you load `fantasyDraft_2025`, `fantasyDraft_2024`, etc., to
     * review past league history.
     *
     * 5.  Advanced Keeper Logic: Implement a settings panel where a user could define
     * keeper rules, such as "a player kept costs a draft pick two rounds higher
     * than where they were drafted last year." The tool could then automatically
     * block out those picks on the board.
    */
  </script>
</body>
</html>