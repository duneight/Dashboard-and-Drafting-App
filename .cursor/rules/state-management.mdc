# State Management Best Practices

## State Management Strategy

### State Classification
```tsx
// ‚úÖ Good: Classify state by scope and lifecycle
type StateType = 
  | 'server-state'      // Data from API/database
  | 'client-state'      // UI state, form data
  | 'global-state'      // App-wide state (auth, theme)
  | 'local-state'       // Component-specific state
  | 'derived-state'     // Computed from other state
  | 'persistent-state'  // Saved to localStorage/DB
```

### State Separation Principles
```tsx
// ‚úÖ Good: Keep server and client state separate
// Server state: User data, posts, analytics
// Client state: UI state, form data, preferences
// Global state: Authentication, theme, language
// Local state: Component-specific interactions
```

## Zustand for Client State

### Basic Store Setup
```tsx
// stores/useAuthStore.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface AuthState {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => void;
  setUser: (user: User) => void;
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      user: null,
      isAuthenticated: false,
      isLoading: false,
      
      login: async (credentials) => {
        set({ isLoading: true });
        try {
          const user = await loginUser(credentials);
          set({ user, isAuthenticated: true, isLoading: false });
        } catch (error) {
          set({ isLoading: false });
          throw error;
        }
      },
      
      logout: () => {
        set({ user: null, isAuthenticated: false });
      },
      
      setUser: (user) => {
        set({ user, isAuthenticated: !!user });
      },
    }),
    {
      name: 'auth-storage',
      partialize: (state) => ({ 
        user: state.user, 
        isAuthenticated: state.isAuthenticated 
      }),
    }
  )
);
```

### Complex Store with Actions
```tsx
// stores/useCartStore.ts
import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';

interface CartItem {
  id: string;
  name: string;
  price: number;
  quantity: number;
}

interface CartState {
  items: CartItem[];
  total: number;
  itemCount: number;
  addItem: (item: Omit<CartItem, 'quantity'>) => void;
  removeItem: (id: string) => void;
  updateQuantity: (id: string, quantity: number) => void;
  clearCart: () => void;
}

export const useCartStore = create<CartState>()(
  immer((set, get) => ({
    items: [],
    total: 0,
    itemCount: 0,
    
    addItem: (item) => {
      set((state) => {
        const existingItem = state.items.find(i => i.id === item.id);
        
        if (existingItem) {
          existingItem.quantity += 1;
        } else {
          state.items.push({ ...item, quantity: 1 });
        }
        
        state.itemCount = state.items.reduce((sum, i) => sum + i.quantity, 0);
        state.total = state.items.reduce((sum, i) => sum + (i.price * i.quantity), 0);
      });
    },
    
    removeItem: (id) => {
      set((state) => {
        state.items = state.items.filter(i => i.id !== id);
        state.itemCount = state.items.reduce((sum, i) => sum + i.quantity, 0);
        state.total = state.items.reduce((sum, i) => sum + (i.price * i.quantity), 0);
      });
    },
    
    updateQuantity: (id, quantity) => {
      set((state) => {
        const item = state.items.find(i => i.id === id);
        if (item) {
          if (quantity <= 0) {
            state.items = state.items.filter(i => i.id !== id);
          } else {
            item.quantity = quantity;
          }
          
          state.itemCount = state.items.reduce((sum, i) => sum + i.quantity, 0);
          state.total = state.items.reduce((sum, i) => sum + (i.price * i.quantity), 0);
        }
      });
    },
    
    clearCart: () => {
      set((state) => {
        state.items = [];
        state.total = 0;
        state.itemCount = 0;
      });
    },
  }))
);
```

### Store Composition
```tsx
// stores/useAppStore.ts
import { create } from 'zustand';
import { useAuthStore } from './useAuthStore';
import { useCartStore } from './useCartStore';

interface AppState {
  theme: 'light' | 'dark';
  language: string;
  sidebarOpen: boolean;
  setTheme: (theme: 'light' | 'dark') => void;
  setLanguage: (lang: string) => void;
  toggleSidebar: () => void;
}

export const useAppStore = create<AppState>((set) => ({
  theme: 'light',
  language: 'en',
  sidebarOpen: false,
  
  setTheme: (theme) => set({ theme }),
  setLanguage: (lang) => set({ language }),
  toggleSidebar: () => set((state) => ({ sidebarOpen: !state.sidebarOpen })),
}));

// ‚úÖ Good: Compose stores for complex state
export const useAppState = () => {
  const auth = useAuthStore();
  const cart = useCartStore();
  const app = useAppStore();
  
  return {
    ...auth,
    ...cart,
    ...app,
    // Computed state
    isLoggedIn: auth.isAuthenticated,
    hasItemsInCart: cart.itemCount > 0,
    isDarkMode: app.theme === 'dark',
  };
};
```

## React Context for Global State

### Context Provider Pattern
```tsx
// contexts/AppContext.tsx
"use client";
import { createContext, useContext, useReducer, ReactNode } from 'react';

interface AppState {
  theme: 'light' | 'dark';
  language: string;
  notifications: Notification[];
}

type AppAction = 
  | { type: 'SET_THEME'; payload: 'light' | 'dark' }
  | { type: 'SET_LANGUAGE'; payload: string }
  | { type: 'ADD_NOTIFICATION'; payload: Notification }
  | { type: 'REMOVE_NOTIFICATION'; payload: string };

const initialState: AppState = {
  theme: 'light',
  language: 'en',
  notifications: [],
};

function appReducer(state: AppState, action: AppAction): AppState {
  switch (action.type) {
    case 'SET_THEME':
      return { ...state, theme: action.payload };
    case 'SET_LANGUAGE':
      return { ...state, language: action.payload };
    case 'ADD_NOTIFICATION':
      return { 
        ...state, 
        notifications: [...state.notifications, action.payload] 
      };
    case 'REMOVE_NOTIFICATION':
      return {
        ...state,
        notifications: state.notifications.filter(n => n.id !== action.payload)
      };
    default:
      return state;
  }
}

const AppContext = createContext<{
  state: AppState;
  dispatch: React.Dispatch<AppAction>;
} | null>(null);

export function AppProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(appReducer, initialState);
  
  return (
    <AppContext.Provider value={{ state, dispatch }}>
      {children}
    </AppContext.Provider>
  );
}

export function useAppContext() {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useAppContext must be used within AppProvider');
  }
  return context;
}
```

### Context with Custom Hooks
```tsx
// contexts/AppContext.tsx (continued)
export function useTheme() {
  const { state, dispatch } = useAppContext();
  
  return {
    theme: state.theme,
    setTheme: (theme: 'light' | 'dark') => 
      dispatch({ type: 'SET_THEME', payload: theme }),
    isDark: state.theme === 'dark',
    toggleTheme: () => 
      dispatch({ 
        type: 'SET_THEME', 
        payload: state.theme === 'light' ? 'dark' : 'light' 
      }),
  };
}

export function useNotifications() {
  const { state, dispatch } = useAppContext();
  
  return {
    notifications: state.notifications,
    addNotification: (notification: Notification) =>
      dispatch({ type: 'ADD_NOTIFICATION', payload: notification }),
    removeNotification: (id: string) =>
      dispatch({ type: 'REMOVE_NOTIFICATION', payload: id }),
    clearAll: () => 
      dispatch({ type: 'SET_NOTIFICATIONS', payload: [] }),
  };
}
```

## Server State Management

### SWR for Server State
```tsx
// hooks/useServerState.ts
import useSWR, { mutate } from 'swr';

export function useUsers() {
  const { data, error, isLoading, mutate: revalidate } = useSWR(
    '/api/users',
    fetcher,
    {
      revalidateOnFocus: false,
      revalidateOnReconnect: true,
      dedupingInterval: 60000,
    }
  );

  const addUser = async (userData: CreateUserData) => {
    try {
      const newUser = await createUser(userData);
      
      // Optimistic update
      mutate('/api/users', (users: User[]) => [newUser, ...users], false);
      
      // Revalidate to ensure consistency
      revalidate();
      
      return newUser;
    } catch (error) {
      // Revert optimistic update on error
      revalidate();
      throw error;
    }
  };

  return {
    users: data || [],
    isLoading,
    error,
    addUser,
    revalidate,
  };
}
```

### React Query for Complex Server State
```tsx
// hooks/useServerState.ts (continued)
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

export function useUserProfile(userId: string) {
  const queryClient = useQueryClient();
  
  const { data: user, isLoading, error } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId),
    staleTime: 5 * 60 * 1000, // 5 minutes
    gcTime: 10 * 60 * 1000,   // 10 minutes
  });

  const updateProfile = useMutation({
    mutationFn: (updates: Partial<User>) => updateUser(userId, updates),
    onMutate: async (updates) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ['user', userId] });
      
      // Snapshot previous value
      const previousUser = queryClient.getQueryData(['user', userId]);
      
      // Optimistically update
      queryClient.setQueryData(['user', userId], (old: User | undefined) => 
        old ? { ...old, ...updates } : undefined
      );
      
      return { previousUser };
    },
    onError: (err, updates, context) => {
      // Rollback on error
      if (context?.previousUser) {
        queryClient.setQueryData(['user', userId], context.previousUser);
      }
    },
    onSettled: () => {
      // Refetch after mutation
      queryClient.invalidateQueries({ queryKey: ['user', userId] });
    },
  });

  return {
    user,
    isLoading,
    error,
    updateProfile: updateProfile.mutate,
    isUpdating: updateProfile.isPending,
  };
}
```

## State Persistence Strategies

### Local Storage with Zustand
```tsx
// stores/useSettingsStore.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface SettingsState {
  theme: 'light' | 'dark';
  language: string;
  sidebarCollapsed: boolean;
  notificationsEnabled: boolean;
  setTheme: (theme: 'light' | 'dark') => void;
  setLanguage: (lang: string) => void;
  toggleSidebar: () => void;
  toggleNotifications: () => void;
}

export const useSettingsStore = create<SettingsState>()(
  persist(
    (set) => ({
      theme: 'light',
      language: 'en',
      sidebarCollapsed: false,
      notificationsEnabled: true,
      
      setTheme: (theme) => set({ theme }),
      setLanguage: (lang) => set({ language }),
      toggleSidebar: () => set((state) => ({ sidebarCollapsed: !state.sidebarCollapsed })),
      toggleNotifications: () => set((state) => ({ notificationsEnabled: !state.notificationsEnabled })),
    }),
    {
      name: 'settings-storage',
      // Only persist specific fields
      partialize: (state) => ({
        theme: state.theme,
        language: state.language,
        sidebarCollapsed: state.sidebarCollapsed,
        notificationsEnabled: state.notificationsEnabled,
      }),
      // Version control for migrations
      version: 1,
      // Migration function
      migrate: (persistedState: any, version: number) => {
        if (version === 0) {
          // Migrate from v0 to v1
          return {
            ...persistedState,
            notificationsEnabled: true, // New field with default
          };
        }
        return persistedState;
      },
    }
  )
);
```

### Session Storage for Temporary State
```tsx
// stores/useSessionStore.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface SessionState {
  lastVisitedPage: string;
  formData: Record<string, any>;
  tempPreferences: Record<string, any>;
  setLastVisitedPage: (page: string) => void;
  setFormData: (key: string, data: any) => void;
  setTempPreference: (key: string, value: any) => void;
  clearSession: () => void;
}

export const useSessionStore = create<SessionState>()(
  persist(
    (set) => ({
      lastVisitedPage: '/',
      formData: {},
      tempPreferences: {},
      
      setLastVisitedPage: (page) => set({ lastVisitedPage: page }),
      setFormData: (key, data) => set((state) => ({
        formData: { ...state.formData, [key]: data }
      })),
      setTempPreference: (key, value) => set((state) => ({
        tempPreferences: { ...state.tempPreferences, [key]: value }
      })),
      clearSession: () => set({ formData: {}, tempPreferences: {} }),
    }),
    {
      name: 'session-storage',
      storage: sessionStorage, // Use sessionStorage instead of localStorage
    }
  )
);
```

## State Optimization Patterns

### Memoization for Expensive Computations
```tsx
// hooks/useOptimizedState.ts
import { useMemo, useCallback } from 'react';
import { useCartStore } from '@/stores/useCartStore';

export function useCartSummary() {
  const { items, total, itemCount } = useCartStore();
  
  // Memoize expensive calculations
  const summary = useMemo(() => {
    const categories = items.reduce((acc, item) => {
      const category = item.category || 'uncategorized';
      acc[category] = (acc[category] || 0) + item.quantity;
      return acc;
    }, {} as Record<string, number>);
    
    const averagePrice = items.length > 0 ? total / itemCount : 0;
    const hasDiscount = items.some(item => item.discount > 0);
    
    return {
      categories,
      averagePrice,
      hasDiscount,
      itemCount,
      total,
    };
  }, [items, total, itemCount]);
  
  // Memoize callbacks
  const getCategoryCount = useCallback((category: string) => {
    return summary.categories[category] || 0;
  }, [summary.categories]);
  
  return {
    ...summary,
    getCategoryCount,
  };
}
```

### Selective State Updates
```tsx
// stores/useOptimizedStore.ts
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';

interface OptimizedState {
  user: User | null;
  preferences: UserPreferences;
  notifications: Notification[];
  updateUser: (updates: Partial<User>) => void;
  updatePreferences: (updates: Partial<UserPreferences>) => void;
  addNotification: (notification: Notification) => void;
}

export const useOptimizedStore = create<OptimizedState>()(
  subscribeWithSelector((set, get) => ({
    user: null,
    preferences: defaultPreferences,
    notifications: [],
    
    updateUser: (updates) => set((state) => ({
      user: state.user ? { ...state.user, ...updates } : null
    })),
    
    updatePreferences: (updates) => set((state) => ({
      preferences: { ...state.preferences, ...updates }
    })),
    
    addNotification: (notification) => set((state) => ({
      notifications: [...state.notifications, notification]
    })),
  }))
);

// ‚úÖ Good: Subscribe to specific state changes
export function useUserSubscription() {
  const user = useOptimizedStore((state) => state.user);
  
  useEffect(() => {
    const unsubscribe = useOptimizedStore.subscribe(
      (state) => state.user,
      (user) => {
        if (user) {
          // User logged in
          analytics.track('user_login', { userId: user.id });
        } else {
          // User logged out
          analytics.track('user_logout');
        }
      }
    );
    
    return unsubscribe;
  }, []);
  
  return user;
}
```

## State Testing Patterns

### Store Testing
```tsx
// stores/__tests__/useAuthStore.test.ts
import { renderHook, act } from '@testing-library/react';
import { useAuthStore } from '../useAuthStore';

describe('useAuthStore', () => {
  beforeEach(() => {
    useAuthStore.setState({
      user: null,
      isAuthenticated: false,
      isLoading: false,
    });
  });

  it('should initialize with default state', () => {
    const { result } = renderHook(() => useAuthStore());
    
    expect(result.current.user).toBeNull();
    expect(result.current.isAuthenticated).toBe(false);
    expect(result.current.isLoading).toBe(false);
  });

  it('should set user and authentication state', () => {
    const { result } = renderHook(() => useAuthStore());
    const testUser = { id: '1', name: 'Test User', email: 'test@example.com' };
    
    act(() => {
      result.current.setUser(testUser);
    });
    
    expect(result.current.user).toEqual(testUser);
    expect(result.current.isAuthenticated).toBe(true);
  });

  it('should handle login flow', async () => {
    const { result } = renderHook(() => useAuthStore());
    
    await act(async () => {
      await result.current.login({ email: 'test@example.com', password: 'password' });
    });
    
    expect(result.current.isLoading).toBe(false);
    expect(result.current.isAuthenticated).toBe(true);
  });
});
```

### Context Testing
```tsx
// contexts/__tests__/AppContext.test.tsx
import { render, screen } from '@testing-library/react';
import { AppProvider, useAppContext } from '../AppContext';

function TestComponent() {
  const { state, dispatch } = useAppContext();
  
  return (
    <div>
      <span data-testid="theme">{state.theme}</span>
      <button onClick={() => dispatch({ type: 'SET_THEME', payload: 'dark' })}>
        Toggle Theme
      </button>
    </div>
  );
}

describe('AppContext', () => {
  it('should provide initial state', () => {
    render(
      <AppProvider>
        <TestComponent />
      </AppProvider>
    );
    
    expect(screen.getByTestId('theme')).toHaveTextContent('light');
  });

  it('should update state through dispatch', () => {
    render(
      <AppProvider>
        <TestComponent />
      </AppProvider>
    );
    
    const button = screen.getByText('Toggle Theme');
    button.click();
    
    expect(screen.getByTestId('theme')).toHaveTextContent('dark');
  });
});
```

## Best Practices Summary

### ‚úÖ Do's
- Use Zustand for client state, SWR/React Query for server state
- Separate concerns: server state ‚â† client state ‚â† global state
- Implement optimistic updates for better UX
- Use immer for complex state updates
- Persist only necessary state
- Memoize expensive computations
- Test state logic thoroughly

### ‚ùå Don'ts
- Don't mix server and client state in the same store
- Don't over-optimize with unnecessary memoization
- Don't store sensitive data in localStorage
- Don't create deeply nested state structures
- Don't forget to clean up subscriptions
- Don't ignore state migration strategies

### üéØ When to Use What
- **Zustand**: Client state, form data, UI state, global preferences
- **React Context**: App-wide state, theme, language, notifications
- **SWR**: Simple server state, real-time data
- **React Query**: Complex server state, mutations, caching
- **Local State**: Component-specific interactions, temporary data
- **Session Storage**: Form data, temporary preferences
- **Local Storage**: User preferences, theme, language
description:
globs:
alwaysApply: false
---
