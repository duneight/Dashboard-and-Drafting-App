# Advanced Authentication & Authorization Patterns

## Authentication Strategy

### Core Principles
```tsx
// ✅ Good: Authentication principles
// - Multi-factor authentication (MFA) for sensitive operations
// - OAuth 2.0 + PKCE for third-party providers
// - Role-based access control (RBAC) for permissions
// - Secure session management with refresh tokens
// - JWT best practices and security
// - Rate limiting for authentication endpoints
```

### Authentication Architecture
```tsx
// ✅ Good: Layered authentication architecture
type AuthenticationLayer = {
  primary: 'email-password' | 'oauth' | 'magic-link';
  secondary: 'mfa' | 'sms' | 'totp' | 'biometric';
  session: 'jwt' | 'database' | 'redis';
  refresh: 'rotation' | 'sliding' | 'fixed';
};

type AuthProvider = {
  name: 'google' | 'github' | 'microsoft' | 'apple';
  scopes: string[];
  callbackUrl: string;
  clientId: string;
  clientSecret: string;
};
```

## Multi-Factor Authentication (MFA)

### MFA Implementation
```tsx
// lib/auth/mfa.ts
import { authenticator } from 'otplib';
import { generateSecret } from 'otplib';
import QRCode from 'qrcode';
import { prisma } from '@/lib/db';
import { sendSMS } from '@/lib/sms';
import { sendEmail } from '@/lib/email';

export class MFAService {
  // Generate TOTP secret for user
  static async generateTOTPSecret(userId: string): Promise<{
    secret: string;
    qrCode: string;
    backupCodes: string[];
  }> {
    const secret = generateSecret();
    const qrCode = await QRCode.toDataURL(
      `otpauth://totp/Vanwyck:${userId}?secret=${secret}&issuer=Vanwyck`
    );
    
    // Generate backup codes
    const backupCodes = Array.from({ length: 10 }, () =>
      Math.random().toString(36).substring(2, 8).toUpperCase()
    );

    // Store encrypted secret and backup codes
    await prisma.user.update({
      where: { id: userId },
      data: {
        mfaSecret: await this.encryptSecret(secret),
        mfaBackupCodes: backupCodes.map(code => 
          await this.hashBackupCode(code)
        ),
        mfaEnabled: true,
      },
    });

    return { secret, qrCode, backupCodes };
  }

  // Verify TOTP token
  static async verifyTOTP(userId: string, token: string): Promise<boolean> {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { mfaSecret: true },
    });

    if (!user?.mfaSecret) return false;

    const secret = await this.decryptSecret(user.mfaSecret);
    return authenticator.verify({ token, secret });
  }

  // Verify backup code
  static async verifyBackupCode(userId: string, code: string): Promise<boolean> {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { mfaBackupCodes: true },
    });

    if (!user?.mfaBackupCodes) return false;

    const hashedCode = await this.hashBackupCode(code);
    const isValid = user.mfaBackupCodes.includes(hashedCode);

    if (isValid) {
      // Remove used backup code
      await prisma.user.update({
        where: { id: userId },
        data: {
          mfaBackupCodes: {
            set: user.mfaBackupCodes.filter(c => c !== hashedCode),
          },
        },
      });
    }

    return isValid;
  }

  // Send SMS verification
  static async sendSMSVerification(userId: string, phone: string): Promise<string> {
    const code = Math.random().toString().substring(2, 8);
    const expiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes

    await prisma.smsVerification.create({
      data: {
        userId,
        phone,
        code,
        expiresAt,
      },
    });

    await sendSMS(phone, `Your Vanwyck verification code is: ${code}`);

    return code;
  }

  // Verify SMS code
  static async verifySMSCode(userId: string, code: string): Promise<boolean> {
    const verification = await prisma.smsVerification.findFirst({
      where: {
        userId,
        code,
        expiresAt: { gt: new Date() },
        used: false,
      },
    });

    if (!verification) return false;

    // Mark as used
    await prisma.smsVerification.update({
      where: { id: verification.id },
      data: { used: true },
    });

    return true;
  }

  private static async encryptSecret(secret: string): Promise<string> {
    // Implement encryption (e.g., using crypto-js or similar)
    return secret; // Placeholder
  }

  private static async decryptSecret(encryptedSecret: string): Promise<string> {
    // Implement decryption
    return encryptedSecret; // Placeholder
  }

  private static async hashBackupCode(code: string): Promise<string> {
    // Implement hashing (e.g., using bcrypt)
    return code; // Placeholder
  }
}
```

### MFA API Routes
```tsx
// app/api/auth/mfa/setup/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { MFAService } from '@/lib/auth/mfa';
import { getCurrentUser } from '@/lib/auth/session';
import { createSuccessResponse, createErrorResponse } from '@/lib/api/response-types';

export async function POST(request: NextRequest) {
  try {
    const user = await getCurrentUser(request);
    if (!user) {
      return NextResponse.json(
        createErrorResponse('UNAUTHORIZED', 'User not authenticated'),
        { status: 401 }
      );
    }

    const { type } = await request.json();
    
    if (type === 'totp') {
      const result = await MFAService.generateTOTPSecret(user.id);
      return NextResponse.json(createSuccessResponse(result));
    } else if (type === 'sms') {
      const { phone } = await request.json();
      await MFAService.sendSMSVerification(user.id, phone);
      return NextResponse.json(
        createSuccessResponse({ message: 'SMS verification sent' })
      );
    }

    return NextResponse.json(
      createErrorResponse('INVALID_TYPE', 'Invalid MFA type'),
      { status: 400 }
    );
  } catch (error) {
    return NextResponse.json(
      createErrorResponse('INTERNAL_ERROR', 'Failed to setup MFA'),
      { status: 500 }
    );
  }
}

// app/api/auth/mfa/verify/route.ts
export async function POST(request: NextRequest) {
  try {
    const user = await getCurrentUser(request);
    if (!user) {
      return NextResponse.json(
        createErrorResponse('UNAUTHORIZED', 'User not authenticated'),
        { status: 401 }
      );
    }

    const { type, code } = await request.json();
    let isValid = false;

    if (type === 'totp') {
      isValid = await MFAService.verifyTOTP(user.id, code);
    } else if (type === 'sms') {
      isValid = await MFAService.verifySMSCode(user.id, code);
    } else if (type === 'backup') {
      isValid = await MFAService.verifyBackupCode(user.id, code);
    }

    if (!isValid) {
      return NextResponse.json(
        createErrorResponse('INVALID_CODE', 'Invalid verification code'),
        { status: 400 }
      );
    }

    // Mark MFA as verified for this session
    // This would typically update a session record or JWT claim

    return NextResponse.json(
      createSuccessResponse({ message: 'MFA verified successfully' })
    );
  } catch (error) {
    return NextResponse.json(
      createErrorResponse('INTERNAL_ERROR', 'Failed to verify MFA'),
      { status: 500 }
    );
  }
}
```

## OAuth 2.0 + PKCE Implementation

### OAuth Configuration
```tsx
// lib/auth/oauth.ts
import { generateRandomString, generateCodeChallenge } from '@/lib/auth/pkce';
import { prisma } from '@/lib/db';

export class OAuthService {
  private static readonly OAUTH_PROVIDERS = {
    google: {
      authUrl: 'https://accounts.google.com/o/oauth2/v2/auth',
      tokenUrl: 'https://oauth2.googleapis.com/token',
      userInfoUrl: 'https://www.googleapis.com/oauth2/v2/userinfo',
      scopes: ['openid', 'email', 'profile'],
    },
    github: {
      authUrl: 'https://github.com/login/oauth/authorize',
      tokenUrl: 'https://github.com/login/oauth/access_token',
      userInfoUrl: 'https://api.github.com/user',
      scopes: ['read:user', 'user:email'],
    },
    microsoft: {
      authUrl: 'https://login.microsoftonline.com/common/oauth2/v2.0/authorize',
      tokenUrl: 'https://login.microsoftonline.com/common/oauth2/v2.0/token',
      userInfoUrl: 'https://graph.microsoft.com/v1.0/me',
      scopes: ['openid', 'profile', 'email'],
    },
  } as const;

  // Generate OAuth authorization URL with PKCE
  static generateAuthUrl(
    provider: keyof typeof OAuthService.OAUTH_PROVIDERS,
    redirectUri: string,
    state?: string
  ): { url: string; codeVerifier: string; state: string } {
    const config = OAuthService.OAUTH_PROVIDERS[provider];
    const codeVerifier = generateRandomString(128);
    const codeChallenge = generateCodeChallenge(codeVerifier);
    const stateParam = state || generateRandomString(32);

    const params = new URLSearchParams({
      client_id: process.env[`${provider.toUpperCase()}_CLIENT_ID`]!,
      redirect_uri: redirectUri,
      response_type: 'code',
      scope: config.scopes.join(' '),
      code_challenge: codeChallenge,
      code_challenge_method: 'S256',
      state: stateParam,
    });

    if (provider === 'github') {
      params.set('response_type', 'code');
    }

    return {
      url: `${config.authUrl}?${params.toString()}`,
      codeVerifier,
      state: stateParam,
    };
  }

  // Exchange authorization code for access token
  static async exchangeCodeForToken(
    provider: keyof typeof OAuthService.OAUTH_PROVIDERS,
    code: string,
    codeVerifier: string,
    redirectUri: string
  ): Promise<{ accessToken: string; refreshToken?: string; expiresIn?: number }> {
    const config = OAuthService.OAUTH_PROVIDERS[provider];
    
    const tokenResponse = await fetch(config.tokenUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        Accept: 'application/json',
      },
      body: new URLSearchParams({
        client_id: process.env[`${provider.toUpperCase()}_CLIENT_ID`]!,
        client_secret: process.env[`${provider.toUpperCase()}_CLIENT_SECRET`]!,
        code,
        code_verifier: codeVerifier,
        redirect_uri: redirectUri,
        grant_type: 'authorization_code',
      }),
    });

    if (!tokenResponse.ok) {
      throw new Error(`Failed to exchange code for token: ${tokenResponse.statusText}`);
    }

    const tokenData = await tokenResponse.json();
    
    return {
      accessToken: tokenData.access_token,
      refreshToken: tokenData.refresh_token,
      expiresIn: tokenData.expires_in,
    };
  }

  // Get user information from OAuth provider
  static async getUserInfo(
    provider: keyof typeof OAuthService.OAUTH_PROVIDERS,
    accessToken: string
  ): Promise<any> {
    const config = OAuthService.OAUTH_PROVIDERS[provider];
    
    const userResponse = await fetch(config.userInfoUrl, {
      headers: {
        Authorization: `Bearer ${accessToken}`,
        Accept: 'application/json',
      },
    });

    if (!userResponse.ok) {
      throw new Error(`Failed to get user info: ${userResponse.statusText}`);
    }

    return userResponse.json();
  }

  // Link OAuth account to existing user
  static async linkOAuthAccount(
    userId: string,
    provider: keyof typeof OAuthService.OAUTH_PROVIDERS,
    providerUserId: string,
    accessToken: string,
    refreshToken?: string
  ): Promise<void> {
    await prisma.oAuthAccount.upsert({
      where: {
        provider_providerUserId: {
          provider,
          providerUserId,
        },
      },
      update: {
        userId,
        accessToken,
        refreshToken,
        updatedAt: new Date(),
      },
      create: {
        provider,
        providerUserId,
        userId,
        accessToken,
        refreshToken,
      },
    });
  }
}
```

### PKCE Implementation
```tsx
// lib/auth/pkce.ts
import crypto from 'crypto';

// Generate random string for code verifier
export function generateRandomString(length: number): string {
  const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
  let text = '';
  
  for (let i = 0; i < length; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }
  
  return text;
}

// Generate code challenge from code verifier
export function generateCodeChallenge(codeVerifier: string): string {
  const hash = crypto.createHash('sha256');
  hash.update(codeVerifier);
  return hash.digest('base64url');
}

// Verify code verifier against code challenge
export function verifyCodeChallenge(codeVerifier: string, codeChallenge: string): boolean {
  const expectedChallenge = generateCodeChallenge(codeVerifier);
  return expectedChallenge === codeChallenge;
}
```

## Role-Based Access Control (RBAC)

### RBAC Implementation
```tsx
// lib/auth/rbac.ts
import { prisma } from '@/lib/db';

export type Permission = 
  | 'users:read'
  | 'users:write'
  | 'users:delete'
  | 'posts:read'
  | 'posts:write'
  | 'posts:delete'
  | 'admin:all';

export type Role = 'user' | 'moderator' | 'admin' | 'super_admin';

export class RBACService {
  // Check if user has specific permission
  static async hasPermission(
    userId: string,
    permission: Permission
  ): Promise<boolean> {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: {
        roles: {
          include: {
            role: {
              include: {
                permissions: true,
              },
            },
          },
        },
      },
    });

    if (!user) return false;

    // Check if user has super admin role
    const isSuperAdmin = user.roles.some(r => r.role.name === 'super_admin');
    if (isSuperAdmin) return true;

    // Check role-based permissions
    const userPermissions = user.roles.flatMap(r => 
      r.role.permissions.map(p => p.name)
    );

    return userPermissions.includes(permission);
  }

  // Check if user has any of the specified permissions
  static async hasAnyPermission(
    userId: string,
    permissions: Permission[]
  ): Promise<boolean> {
    for (const permission of permissions) {
      if (await this.hasPermission(userId, permission)) {
        return true;
      }
    }
    return false;
  }

  // Check if user has all specified permissions
  static async hasAllPermissions(
    userId: string,
    permissions: Permission[]
  ): Promise<boolean> {
    for (const permission of permissions) {
      if (!(await this.hasPermission(userId, permission))) {
        return false;
      }
    }
    return true;
  }

  // Get user's effective permissions
  static async getUserPermissions(userId: string): Promise<Permission[]> {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: {
        roles: {
          include: {
            role: {
              include: {
                permissions: true,
              },
            },
          },
        },
      },
    });

    if (!user) return [];

    // Check if user has super admin role
    const isSuperAdmin = user.roles.some(r => r.role.name === 'super_admin');
    if (isSuperAdmin) {
      return ['admin:all'];
    }

    // Get role-based permissions
    return user.roles.flatMap(r => 
      r.role.permissions.map(p => p.name as Permission)
    );
  }

  // Assign role to user
  static async assignRole(
    userId: string,
    roleName: Role,
    assignedBy: string
  ): Promise<void> {
    const role = await prisma.role.findUnique({
      where: { name: roleName },
    });

    if (!role) {
      throw new Error(`Role ${roleName} not found`);
    }

    await prisma.userRole.create({
      data: {
        userId,
        roleId: role.id,
        assignedBy,
        assignedAt: new Date(),
      },
    });
  }

  // Remove role from user
  static async removeRole(userId: string, roleName: Role): Promise<void> {
    const role = await prisma.role.findUnique({
      where: { name: roleName },
    });

    if (!role) return;

    await prisma.userRole.deleteMany({
      where: {
        userId,
        roleId: role.id,
      },
    });
  }
}
```

### RBAC Middleware
```tsx
// lib/auth/rbac-middleware.ts
import { NextRequest, NextResponse } from 'next/server';
import { RBACService, Permission } from '@/lib/auth/rbac';
import { getCurrentUser } from '@/lib/auth/session';

export function withPermission(permission: Permission) {
  return async (request: NextRequest) => {
    const user = await getCurrentUser(request);
    
    if (!user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const hasPermission = await RBACService.hasPermission(user.id, permission);
    
    if (!hasPermission) {
      return NextResponse.json(
        { error: 'Forbidden' },
        { status: 403 }
      );
    }

    return NextResponse.next();
  };
}

export function withAnyPermission(permissions: Permission[]) {
  return async (request: NextRequest) => {
    const user = await getCurrentUser(request);
    
    if (!user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const hasPermission = await RBACService.hasAnyPermission(user.id, permissions);
    
    if (!hasPermission) {
      return NextResponse.json(
        { error: 'Forbidden' },
        { status: 403 }
      );
    }

    return NextResponse.next();
  };
}

export function withAllPermissions(permissions: Permission[]) {
  return async (request: NextRequest) => {
    const user = await getCurrentUser(request);
    
    if (!user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const hasPermission = await RBACService.hasAllPermissions(user.id, permissions);
    
    if (!hasPermission) {
      return NextResponse.json(
        { error: 'Forbidden' },
        { status: 403 }
      );
    }

    return NextResponse.next();
  };
}
```

## Session Management

### Session Service
```tsx
// lib/auth/session.ts
import { prisma } from '@/lib/db';
import { createJWT, verifyJWT, refreshJWT } from '@/lib/auth/jwt';
import { RBACService } from '@/lib/auth/rbac';

export class SessionService {
  // Create new session
  static async createSession(
    userId: string,
    deviceInfo?: {
      userAgent?: string;
      ip?: string;
      deviceId?: string;
    }
  ): Promise<{
    accessToken: string;
    refreshToken: string;
    expiresIn: number;
  }> {
    // Get user permissions for JWT claims
    const permissions = await RBACService.getUserPermissions(userId);
    
    // Create access token
    const accessToken = await createJWT({
      userId,
      permissions,
      type: 'access',
    });

    // Create refresh token
    const refreshToken = await createJWT({
      userId,
      type: 'refresh',
    });

    // Store session in database
    await prisma.session.create({
      data: {
        userId,
        accessToken: await this.hashToken(accessToken),
        refreshToken: await this.hashToken(refreshToken),
        userAgent: deviceInfo?.userAgent,
        ipAddress: deviceInfo?.ip,
        deviceId: deviceInfo?.deviceId,
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days
      },
    });

    return {
      accessToken,
      refreshToken,
      expiresIn: 15 * 60, // 15 minutes
    };
  }

  // Refresh access token
  static async refreshSession(refreshToken: string): Promise<{
    accessToken: string;
    expiresIn: number;
  }> {
    // Verify refresh token
    const payload = await verifyJWT(refreshToken, 'refresh');
    
    // Check if session exists and is valid
    const session = await prisma.session.findFirst({
      where: {
        refreshToken: await this.hashToken(refreshToken),
        expiresAt: { gt: new Date() },
        revoked: false,
      },
    });

    if (!session) {
      throw new Error('Invalid or expired refresh token');
    }

    // Get updated user permissions
    const permissions = await RBACService.getUserPermissions(payload.userId);
    
    // Create new access token
    const accessToken = await createJWT({
      userId: payload.userId,
      permissions,
      type: 'access',
    });

    return {
      accessToken,
      expiresIn: 15 * 60, // 15 minutes
    };
  }

  // Revoke session
  static async revokeSession(refreshToken: string): Promise<void> {
    const hashedToken = await this.hashToken(refreshToken);
    
    await prisma.session.updateMany({
      where: { refreshToken: hashedToken },
      data: { revoked: true },
    });
  }

  // Revoke all user sessions
  static async revokeAllUserSessions(userId: string): Promise<void> {
    await prisma.session.updateMany({
      where: { userId },
      data: { revoked: true },
    });
  }

  // Get active sessions for user
  static async getUserSessions(userId: string): Promise<any[]> {
    return prisma.session.findMany({
      where: {
        userId,
        revoked: false,
        expiresAt: { gt: new Date() },
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  private static async hashToken(token: string): Promise<string> {
    // Implement token hashing for storage
    return token; // Placeholder
  }
}
```

## JWT Best Practices

### JWT Service
```tsx
// lib/auth/jwt.ts
import jwt from 'jsonwebtoken';
import crypto from 'crypto';

export interface JWTPayload {
  userId: string;
  permissions?: string[];
  type: 'access' | 'refresh';
  iat?: number;
  exp?: number;
}

export class JWTService {
  private static readonly ACCESS_TOKEN_SECRET = process.env.JWT_ACCESS_SECRET!;
  private static readonly REFRESH_TOKEN_SECRET = process.env.JWT_REFRESH_SECRET!;
  private static readonly ACCESS_TOKEN_EXPIRY = '15m';
  private static readonly REFRESH_TOKEN_EXPIRY = '7d';

  // Create JWT token
  static async createToken(
    payload: Omit<JWTPayload, 'iat' | 'exp'>,
    type: 'access' | 'refresh'
  ): Promise<string> {
    const secret = type === 'access' 
      ? this.ACCESS_TOKEN_SECRET 
      : this.REFRESH_TOKEN_SECRET;
    
    const expiry = type === 'access' 
      ? this.ACCESS_TOKEN_EXPIRY 
      : this.REFRESH_TOKEN_EXPIRY;

    return jwt.sign(payload, secret, {
      expiresIn: expiry,
      issuer: 'vanwyck',
      audience: type === 'access' ? 'vanwyck-app' : 'vanwyck-refresh',
      jwtid: crypto.randomUUID(),
    });
  }

  // Verify JWT token
  static async verifyToken(
    token: string,
    type: 'access' | 'refresh'
  ): Promise<JWTPayload> {
    const secret = type === 'access' 
      ? this.ACCESS_TOKEN_SECRET 
      : this.REFRESH_TOKEN_SECRET;
    
    const audience = type === 'access' ? 'vanwyck-app' : 'vanwyck-refresh';

    try {
      const payload = jwt.verify(token, secret, {
        issuer: 'vanwyck',
        audience,
      }) as JWTPayload;

      return payload;
    } catch (error) {
      if (error instanceof jwt.TokenExpiredError) {
        throw new Error('Token expired');
      } else if (error instanceof jwt.JsonWebTokenError) {
        throw new Error('Invalid token');
      }
      throw error;
    }
  }

  // Decode JWT without verification (for debugging)
  static decodeToken(token: string): JWTPayload | null {
    try {
      return jwt.decode(token) as JWTPayload;
    } catch {
      return null;
    }
  }

  // Check if token is expired
  static isTokenExpired(token: string): boolean {
    try {
      const decoded = jwt.decode(token) as JWTPayload;
      if (!decoded.exp) return true;
      
      return Date.now() >= decoded.exp * 1000;
    } catch {
      return true;
    }
  }
}

// Convenience functions
export const createJWT = JWTService.createToken.bind(JWTService);
export const verifyJWT = JWTService.verifyToken.bind(JWTService);
export const decodeJWT = JWTService.decodeToken.bind(JWTService);
```

## Best Practices Summary

### ✅ Do's
- Implement MFA for sensitive operations
- Use OAuth 2.0 + PKCE for third-party providers
- Implement role-based access control (RBAC)
- Use secure session management with refresh tokens
- Follow JWT security best practices
- Implement rate limiting for auth endpoints
- Use secure password hashing (bcrypt)
- Implement account lockout after failed attempts
- Use HTTPS for all authentication
- Implement proper logout and session cleanup

### ❌ Don'ts
- Don't store sensitive data in JWT payloads
- Don't use weak password requirements
- Don't skip MFA for admin accounts
- Don't forget to validate OAuth tokens
- Don't use predictable session IDs
- Don't skip rate limiting on auth endpoints
- Don't store passwords in plain text
- Don't ignore session expiration

### 🔧 Implementation Checklist
- [ ] Set up multi-factor authentication (TOTP, SMS)
- [ ] Implement OAuth 2.0 + PKCE for third-party providers
- [ ] Create role-based access control system
- [ ] Implement secure session management
- [ ] Set up JWT with proper security
- [ ] Add rate limiting for authentication endpoints
- [ ] Implement account lockout mechanisms
- [ ] Set up secure password policies
- [ ] Test authentication flows thoroughly
- [ ] Monitor authentication security events
description:
globs:
alwaysApply: false
---
description:
globs:
alwaysApply: false
---
